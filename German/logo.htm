<!doctype html public "-//w3c//dtd html 4.0 transitional//en">
<html>
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
   <meta name="GENERATOR" content="Mozilla/4.5 [en] (WinNT; I) [Netscape]">
   <meta name="Template" content="C:\Program Files\Microsoft Office\Office\HTML.DOT">
   <title>Is Logo old technology?</title>
</head>
<body bgcolor="#FFFFFF" link="#0000FF" vlink="#800080">
<i><font face="Comic Sans MS"></font></i>&nbsp;
<br><i><font face="Comic Sans MS">This is a discussion that was held on
<font color="#0000FF"><a href="news:comp.lang.logo">comp.lang.logo</a></font>
(and the corresponding email discussion list) from November 16 to December
2, 1998. The discussion entitled "Is <a href="http://el.www.media.mit.edu/logo-foundation/">Logo</a>
old technology?" was started by the following message:</font></i>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">I recall an MIT Logo group meeting in 1977
where Seymour Papert described Logo as an attempt to take the best ideas
from computer science and make them accessible to children. Most of those
ideas had come from the Lisp programming language. I think this was a wonderful
choice when it was made 30 years ago.</font>
<p><font face="Comic Sans MS">Computer science has moved forward and Logo
has barely changed. Yes, LCSI Microworlds Logo adds some nice user interface
gadgets and a very impoverished way of running programs in parallel. (Concurrent
programs can't really synchronize and can only communicate via global variables.)
StarLogo does borrow ideas from computer science but its SIMD model of
computation is not flexible enough for the wide range of things that kids
might want to program computers to do. It is a good thing only when dealing
with problems that are naturally "data parallel". Object Logo and Multi
Logo were attempts to borrow from computer science object-oriented programming
and parallel processing respectively. But they didn't catch on.</font>
<p><font face="Comic Sans MS">Logo was a good attempt at "child engineering"
the ideas in Lisp. And more modern Logo implementations have kept up a
bit by including menus, buttons, mice, windows, and the like. But here
Logo is just trying to catch up with systems like Visual Basic. And both
systems pale compared to the ease of use of user interfaces in computer
and video games.</font>
<p><font face="Comic Sans MS">During the last 20 years I have tried 4 times
to make a new and better programming system for kids that shares Logo's
pedagogic/epistimologic/constructivist view. Each time I tried to follow
the original design goals of Logo by "child engineering" the best ideas
from computer science. First I tried to introduce object-oriented programming
(Smalltalk 72 was doing the same thing but was a corporate secret at the
time). Then logic programming. Then visual programming.</font>
<p><font face="Comic Sans MS">ToonTalk (<a href="http://www.toontalk.com/">www.toontalk.com</a>)
is my most recent attempt. It is based upon what I call "animated programming"
where a child does all her programming by manipulating concrete objects
inside of an animated game-like world. ToonTalk is a general purpose language
where a child programs by training robots, giving birds messages to deliver,
manipulating boxes, text pads, and number pads, using animated tools, loading
trucks and more. The child is a character in this world and can even fly
her helicopter to travel between houses or to see an overview of an ongoing
computation.</font>
<p><font face="Comic Sans MS">ToonTalk borrows ideas from computer science
about how to program with communicating independent processes. Everything
happens in parallel in ToonTalk. There are ways of expressing process spawning,
communication, synchronization, and termination. It also borrows from demonstrative
and visual programming research.</font>
<p><font face="Comic Sans MS">Anecdotal evidence is that kids enjoy ToonTalk
and master it relatively quickly. (See <a href="http://www.toontalk.com/English/users.htm">www.toontalk.com/English/users.htm</a>)
A large pan-European research project just began on the first of the month
that will be building what they call "playgrounds" on top of ToonTalk and
Logo. (See <a href="http://www.ioe.ac.uk/playground">www.ioe.ac.uk/playground</a>)
They plan to do careful studies of kids using both systems. I'm betting
the ToonTalk half comes out ahead.</font>
<p><font face="Comic Sans MS">I think Logo is a good thing - it is just
that it could be so much more than it is.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">I received a reply to my posting from Wen
Su (<a href="mailto:wens@ncct.sps.mot.com">wens@ncct.sps.mot.com</a>) by
email and with his permission I am posting his message and my response
to it.</font>
<p><font face="Comic Sans MS">Wen Su&nbsp; wrote:</font>
<br><font face="Comic Sans MS">>Should the new generation learn concurrent
programming</font>
<br><font face="Comic Sans MS">>and declarative style programming only,
totally skipping</font>
<br><font face="Comic Sans MS">>the "traditional" sequential programming?</font>
<p><font face="Comic Sans MS">>This is a big question. If yes, ToonTalk's
approach</font>
<br><font face="Comic Sans MS">>is definitely the way to go, no doubt about
it. In my own</font>
<br><font face="Comic Sans MS">>opinion, it is easier for most people to
adopt the declarative</font>
<br><font face="Comic Sans MS">>programming style than the concurrent programming
style.</font>
<br><font face="Comic Sans MS">>For example, SQL, as used in data base,
is declarative.</font>
<br><font face="Comic Sans MS">>It starts to be accepted universally these
days. No people</font>
<br><font face="Comic Sans MS">>would say relational data base is slow
today; people only</font>
<br><font face="Comic Sans MS">>cares about the "productivity" it has to
offer.</font>
<p><font face="Comic Sans MS">This is the big question, I agree. I see
value in kids learning many different programming paradigms. Among them
are</font>
<p><font face="Comic Sans MS">1. Concurrent object-oriented languages like
ToonTalk. 2. Sequential procedural languages like Logo. 3. Declarative
or logic programming languages like Prolog. (See Brian Harvey's recent
posting. I should maybe clarify that while ToonTalk has borrowed lots of
ideas from logic programming, it doesn't have the nice query and running
programs backwards ability of Prolog that Brian described.) 4. Data parallelism
like StarLogo. 5. Others. Maybe pure functional programming. Or production
systems like Stagecast Creator (formerly known as KidSim and Cocoa).</font>
<p><font face="Comic Sans MS">While I think in the ideal world kids should
learn all these different ways of thinking about computation, the real
world has limited resources. If I had to prioritize these ways of thinking
about programming I would stick to the order I listed them above. Others
might prefer other orderings. What criteria should we use to decide this?
Naturalness? Generality? Scalability? Elegance? Current popularity among
professional programmers? Popularity among computer scientists? Another
question is which one should be learned first? And which ones have the
best chances of being useful for understanding or solving problems in domains
other than programming?</font>
<p><font face="Comic Sans MS">>When I read a posting at your web site:
"Axiom 1: the more</font>
<br><font face="Comic Sans MS">>you know about C/C++, the less you know
about ToonTalk."</font>
<br><font face="Comic Sans MS">>I laugh but can not agree more at this.
This reminds me of</font>
<br><font face="Comic Sans MS">>a saying back in those days when C++ and
object C were just</font>
<br><font face="Comic Sans MS">>introduced: A person who likes Object C
tends to dislike C++,</font>
<br><font face="Comic Sans MS">>and vice versa. I hope the similar thing
won't happen for</font>
<br><font face="Comic Sans MS">>Logo and ToonTalk: A person who likes Logo
tends to</font>
<br><font face="Comic Sans MS">>dislike ToonTalk, and vice versa. Just
a joke here :-)</font>
<p><font face="Comic Sans MS">>Seriously, though, I believe there is a
force that is</font>
<br><font face="Comic Sans MS">>working behind this: Most "average" people
tend to like what</font>
<br><font face="Comic Sans MS">>they have already known about, even though
what they</font>
<br><font face="Comic Sans MS">>have already known about is not as good
as the new one.</font>
<br><font face="Comic Sans MS">>If this is true, this works against the
acceptance of</font>
<br><font face="Comic Sans MS">>ToonTalk because the constructs in Logo
is more familiar</font>
<br><font face="Comic Sans MS">>to most people (esp. to the so-called technology
teachers).</font>
<br><font face="Comic Sans MS">>On the other hand, ToonTalk may be more
appeal to the</font>
<br><font face="Comic Sans MS">>children. If ToonTalk can be as fun as,
say, SNES's Zelda LTP,</font>
<br><font face="Comic Sans MS">>or the Zelda-64 to be released in a week
or two, it definitely</font>
<br><font face="Comic Sans MS">>could win the "war." But those technology
"old dogs" (maybe</font>
<br><font face="Comic Sans MS">>I am one of them because I am trained to
be a C programmer)</font>
<br><font face="Comic Sans MS">>may be in the way and need to find a strategy
to make them</font>
<br><font face="Comic Sans MS">>feel home at this new environment.</font>
<p><font face="Comic Sans MS">I agree most people like what they already
know. This might mean that teachers won't give ToonTalk the chance it deserves.
But as you point out what appeals to children is also important here. Nintendo
SNES's Zelda was a source of ideas and inspiration in building ToonTalk.
I don't think I've come close to the charm and appeal of that game, but
I think I have come closer than any other "educational" software that I
know of.</font>
<p><font face="Comic Sans MS">>This is just a thought from a newbie. I
am still reading</font>
<br><font face="Comic Sans MS">>the documents about ToonTalk at your web
site and may</font>
<br><font face="Comic Sans MS">>decide to order one. My 10-year-old son
has been familiar with</font>
<br><font face="Comic Sans MS">>MicroWorlds and I may want him to play
with ToonTalk some day.</font>
<br><font face="Comic Sans MS">>Zelda LTP on SNES was his beloved game
when he was about 7 (?).</font>
<br><font face="Comic Sans MS">>He is playing so-called RealTime strategy
games on PC these days.</font>
<p><font face="Comic Sans MS">>Regards,</font>
<br><font face="Comic Sans MS">>Wen Su</font>
<p><font face="Comic Sans MS">Thanks for your insightful comments.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ehud Lamm:</font>
<p><font face="Comic Sans MS">"ToonTalk versus Logo". Before saying one
more word, I have to admit I didn't check the toontalk site yet. But...</font>
<p><font face="Comic Sans MS">I once thought about doing alittle experiment
and writing an article comparing how people "think" with TIM (The Incredible
Machine, computer game) and how they think with Logo.</font>
<p><font face="Comic Sans MS">I believe that aisde from all else, one of
Logo's greatest strengths is that it is a language.</font>
<p><font face="Comic Sans MS">When I consider the way my thinking changed
over the years, I think the most crucial point was grasping the concept
of ANGUAGE. This concept, and the intuitive feeling I have of it, helped
me in studiying CS and also in thinking about other issues. Logo was one
of my first exposures to language. Indeed, a computer language and not
a human tongue, but none the</font>
<br><font face="Comic Sans MS">less a language where you have to try to
put linear syntax on your ideas. A system in which semantics are tied to
syntax.</font>
<p><font face="Comic Sans MS">I also think that being a computer language,
Logo helps in giving a good method for structuring algorithms into self
contained parts, and building complex strucutures.</font>
<p><font face="Comic Sans MS">I did look for other ideas (and there are
many ideas in trying to find a better method for programming a computer,
than using a computer language), and was always dissatisfied. I wanted
the flexebility, genericity and elegance of Logo.</font>
<p><font face="Comic Sans MS">I think that the great thing about Logo is
that it is not really a protective enviroment. It is REAL. You can get
infinite loops, you can do harm. You have the real thing under your hands.
Kids shouldn't settle for less.</font>
<p><font face="Comic Sans MS">(Note: This is not against ToonTalk, which
as I said I know nothing about. Only general comments about computer languages
as superior to any other way of teaching kids through computers).</font>
<p><font face="Comic Sans MS">(Second note. This is somehow also connected
to the theme of Hands-On Learning. A short piece on this topic can be find
in the archive on my web site.)</font>
<p><font face="Comic Sans MS">Ehud Lamm <a href="mailto:mslamm@mscc.huji.ac.il">mslamm@mscc.huji.ac.il</a></font>
<br><font face="Comic Sans MS"><a href="http://www2.cybercities.com/e/ehud">http://www2.cybercities.com/e/ehud</a>
- Some of the work a MISCologist.</font>
<br>&nbsp;
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Ehud Lamm wrote in message ...</font>
<br><font face="Comic Sans MS">>I once thought about doing alittle experiment
and writing an article</font>
<br><font face="Comic Sans MS">>comparing how people "think" with TIM (The
Incredible Machine, computer</font>
<br><font face="Comic Sans MS">>game) and how they think with Logo.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">Sounds interesting. I'd read it if you wrote
it.</font>
<p><font face="Comic Sans MS">>I believe that aisde from all else, one
of Logo's greatest strengths is</font>
<br><font face="Comic Sans MS">>that it is a language.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>When I consider the way my thinking changed
over the years, I think the</font>
<br><font face="Comic Sans MS">>most crucial point was grasping the concept
of LANGUAGE. This concept, and</font>
<br><font face="Comic Sans MS">>the intuitive feeling I have of it, helped
me in studiying CS and also in</font>
<br><font face="Comic Sans MS">>thinking about other issues. Logo was one
of my first exposures to</font>
<br><font face="Comic Sans MS">>language. Indeed, a computer language and
not a human tongue, but none the</font>
<br><font face="Comic Sans MS">>less a language where you have to try to
put linear syntax on your ideas.</font>
<br><font face="Comic Sans MS">>A system in which semantics are tied to
syntax.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">Here's maybe where we need some philosophers
to jump in. For a while, sign language was not accepted as a proper language
- now it is. People talk about the language of film (referring to the syntax
of close-ups, cuts, dissolves, etc.). Is ToonTalk really a language? Does
it have a syntax, much less a linear one? I'm not sure that language is
the best word to describe ToonTalk, but I am sure it shares the nice properties
that programming languages have.</font>
<p><font face="Comic Sans MS">>I also think that being a computer language,
Logo helps in giving a good</font>
<br><font face="Comic Sans MS">>method for structuring algorithms into
self contained parts, and building</font>
<br><font face="Comic Sans MS">>complex strucutures.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">Ditto for ToonTalk.</font>
<p><font face="Comic Sans MS">>I did look for other ideas (and there are
many ideas in trying to find a</font>
<br><font face="Comic Sans MS">>better method for programming a computer,
than using a computer language),</font>
<br><font face="Comic Sans MS">>and was always dissatisfied. I wanted the
flexebility, genericity and</font>
<br><font face="Comic Sans MS">>elegance of Logo.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">ToonTalk is flexible and generic. I think
it is elegant too.</font>
<p><font face="Comic Sans MS">>I think that the great thing about Logo
is that it is not really a</font>
<br><font face="Comic Sans MS">>protective enviroment. It is REAL. You
can get infinite loops, you can do</font>
<br><font face="Comic Sans MS">>harm. You have the real thing under your
hands. Kids shouldn't settle for</font>
<br><font face="Comic Sans MS">>less.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">I agree and ToonTalk is real in the same
way that Logo is.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn (<a href="http://www.toontalk.com/">www.toontalk.com</a>)</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ehud Lamm:</font>
<p><font face="Comic Sans MS">On Thu, 26 Nov 1998, Ken Kahn wrote:</font>
<p><font face="Comic Sans MS">> Ehud Lamm wrote in message ...</font>
<br><font face="Comic Sans MS">> >I once thought about doing alittle experiment
and writing an article</font>
<br><font face="Comic Sans MS">> >comparing how people "think" with TIM
(The Incredible Machine, computer</font>
<br><font face="Comic Sans MS">> >game) and how they think with Logo.</font>
<br><font face="Comic Sans MS">> ></font>
<br><font face="Comic Sans MS">> Sounds interesting. I'd read it if you
wrote it.</font>
<p><font face="Comic Sans MS">Maybe I'll have the time to write it. If
I do - I'll let you know!</font>
<p><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">> >I believe that aisde from all else, one
of Logo's greatest strengths is</font>
<br><font face="Comic Sans MS">> >that it is a language.</font>
<br><font face="Comic Sans MS">> ></font>
<br><font face="Comic Sans MS">> >When I consider the way my thinking changed
over the years, I think the</font>
<br><font face="Comic Sans MS">> >most crucial point was grasping the concept
of LANGUAGE. This concept, and</font>
<br><font face="Comic Sans MS">> >the intuitive feeling I have of it, helped
me in studiying CS and also in</font>
<br><font face="Comic Sans MS">> >thinking about other issues. Logo was
one of my first exposures to</font>
<br><font face="Comic Sans MS">> >language. Indeed, a computer language
and not a human tongue, but none the</font>
<br><font face="Comic Sans MS">> >less a language where you have to try
to put linear syntax on your ideas.</font>
<br><font face="Comic Sans MS">> >A system in which semantics are tied
to syntax.</font>
<br><font face="Comic Sans MS">> ></font>
<br><font face="Comic Sans MS">> Here's maybe where we need some philosophers
to jump in. For a while, sign</font>
<br><font face="Comic Sans MS">> language was not accepted as a proper
language - now it is. People talk</font>
<br><font face="Comic Sans MS">> about the language of film (referring
to the syntax of close-ups, cuts,</font>
<br><font face="Comic Sans MS">> dissolves, etc.). Is ToonTalk really a
language? Does it have a syntax, much</font>
<br><font face="Comic Sans MS">> less a linear one? I'm not sure that language
is the best word to describe</font>
<br><font face="Comic Sans MS">> ToonTalk, but I am sure it shares the
nice properties that programming</font>
<br><font face="Comic Sans MS">> languages have.</font>
<p><font face="Comic Sans MS">Wll I do tend to see my self more as a philopher
than any thing else (even</font>
<br><font face="Comic Sans MS">though my field of work and studies was
CS up till now).</font>
<p><font face="Comic Sans MS">I will not try to define what a language
is, since this really is a loaded</font>
<br><font face="Comic Sans MS">question. But I do think some remakrs are
inorder.</font>
<p><font face="Comic Sans MS">Sign language was considered as a form of
of non-verbal, lower than human</font>
<br><font face="Comic Sans MS">communication, until hearing people tried
to learn it, and found out it</font>
<br><font face="Comic Sans MS">has the complexities of other languages.
See Oliver Sack's book on this,</font>
<br><font face="Comic Sans MS">and if you are interested in more details
see Ursula Bellugi (speeling is</font>
<br><font face="Comic Sans MS">wrong here, I am sure. Sorry)</font>
<p><font face="Comic Sans MS">But it is none the less possible to clearly
see when the term language is</font>
<br><font face="Comic Sans MS">used litteraly and when it used metaphorically.
"The Language of Cinema"</font>
<br><font face="Comic Sans MS">is not the same as "The language used in
France". The concepts are not the</font>
<br><font face="Comic Sans MS">same.</font>
<p><font face="Comic Sans MS">What I'd consider important in a programming
language is that it have a</font>
<br><font face="Comic Sans MS">clear syntax (even when graphical) AND clear
semantics.</font>
<p><font face="Comic Sans MS">I'd also want some of the things we are accustomed
to in programming</font>
<br><font face="Comic Sans MS">languages, like support for common control
structures (looping, branching,</font>
<br><font face="Comic Sans MS">recursion), and data strctures (list are
fine!)</font>
<p><font face="Comic Sans MS">One of the basic features languages have
is the ability to build complex</font>
<br><font face="Comic Sans MS">structures from the ground up. You can use
word in sentences, sentences in</font>
<br><font face="Comic Sans MS">paragraphs etc etc. In prog. languages you
can define procedures and use</font>
<br><font face="Comic Sans MS">them in place of coding them again. I see
theis aspect of managing thought</font>
<br><font face="Comic Sans MS">(by defining "concepts") and complexity
highly important. I think it one</font>
<br><font face="Comic Sans MS">of the basic things I learned from Logo.</font>
<p><font face="Comic Sans MS">Ehud Lamm&nbsp;&nbsp;&nbsp;&nbsp; <a href="mailto:mslamm@mscc.huji.ac.il">mslamm@mscc.huji.ac.il</a></font>
<br><font face="Comic Sans MS"><a href="http://www2.cybercities.com/e/ehud/">http://www2.cybercities.com/e/ehud/</a>&nbsp;&nbsp;&nbsp;&nbsp;
Subscribe to the E-List today!</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Dale R. Reed:</font>
<p><font face="Comic Sans MS">>I think Logo is a good thing - it is just
that it could be so much more than it is.</font>
<p><font face="Comic Sans MS">Ken, I just surfed to your site and ordered
ToonTalk.</font>
<p><font face="Comic Sans MS">But I must admit that I(63 year old retired
Electromagnetics Engineer) am more interested in creating fractals and
knots and moir&eacute; patterns and other objects that I see in Mother
Nature or imagine. And I don't think I have changed that much on these
accounts over the last 50 years.</font>
<p><font face="Comic Sans MS">I keep thinking about drawing knots with
Logo just like I used to think about the lightning currents that I was
modeling and responsible for protecting against as they redistributed(in
frequency and time) through the graphite composite and aluminum horizontal
stabilizer of the being designed fly-by-wire 777.&nbsp; The lightning currents
in the past and now the knots and moir&eacute; patterns stir my mind during
restless nights sleeps.</font>
<p><font face="Comic Sans MS">I do not like games and I do not find Microworlds
all that much fun. It was OK when my little grandsonny lived nearby and
he used to sit on my lap and we would create imaginary worlds with dogs
and trees and moons but he lives two hours drive away now and growing up
very quickly so what I want now is an efficient and powerful way of creating
my own designs.</font>
<p><font face="Comic Sans MS">Something that will force my mind to pay
attention to detail and offers me the capability to create something interesting
that Katy and I can enjoy.&nbsp; MSWLogo works just fine for my purposes.&nbsp;
I bet I am not that much different than many youngsters.</font>
<p><font face="Comic Sans MS">But Ken, I like new things and will give
ToonTalk a go.</font>
<p><font face="Comic Sans MS">Dale --- $ <a href="mailto:dale-reed@worldnet.att.net">dale-reed@worldnet.att.net</a>&nbsp;
Seattle, Washington U.S.A. $</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ray Catzel:</font>
<p><font face="Comic Sans MS">I am an avid supporter of MicroWorlds because
of the outstanding success I have experienced enriching hundreds of kids
over the past number of years.</font>
<p><font face="Comic Sans MS">One of the great advantages of MicroWorlds
is its ability to bridge the gap between objects that are meaningful to
children and program coding. You can get away with minimal coding for the
youngsters and provide very challenging (and more abstract) projects for
the older kids.</font>
<p><font face="Comic Sans MS">I took a brief look at toontalk and can't
find the ability to migrate smoothly from "giving objects instructions"
to coding syntax.</font>
<p><font face="Comic Sans MS">I have no criticism of "old" technology if
it is stable and achieves learning objectives. Parallel, smarallel - do
you really think the child cares how the programs run in the background.</font>
<p><font face="Comic Sans MS">Have Fun!</font>
<p><font face="Comic Sans MS">Ray Catzel, President, ComputerPals Inc.</font>
<p><font face="Comic Sans MS">Web site: <a href="http://www.computerpals.on.ca/~pals">http://www.computerpals.on.ca/~pals</a></font>
<p><font face="Comic Sans MS">Email: <a href="mailto:learn@computerpals.on.ca">learn@computerpals.on.ca</a></font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">RAY CATZEL wrote ...</font>
<br><font face="Comic Sans MS">>One of the great advantages of MicroWorlds
is its ability to bridge the gap</font>
<br><font face="Comic Sans MS">>between objects that are meaningful to
children and program coding. You can</font>
<br><font face="Comic Sans MS">>get away with minimal coding for the youngsters
and provide very challenging</font>
<br><font face="Comic Sans MS">>(and more abstract) projects for the older
kids.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>I took a brief look at toontalk and can't
find the ability to migrate</font>
<br><font face="Comic Sans MS">>smoothly from "giving objects instructions"
to coding syntax.</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">I agree one wants software to span a wide
range of abilities and ambitions. I believe ToonTalk does this since one
can just play with ToonTalk and maybe put together some objects built by
others or one can explore serious computer science topics -- e.g. constructing
a parallel quick sort program that is laid out so that one can see the
overall computation in a meaningful way.</font>
<p><font face="Comic Sans MS">But I don't put much value on "coding syntax".
What I do value are the underlying concepts -- variables, recursion, data
structures, conditionals, etc. Turns out if you look really hard there
is a way of bridging the gap from ToonTalk to coding syntax. ToonTalk can
generate a Java applet of whatever you have programmed in ToonTalk. Effort
was made so that the generated Java code is readable -- nice variables
names, comments, etc. So there is a bridge to textual programming but I
don't see it as a vital component of ToonTalk.</font>
<br>&nbsp;
<p><font face="Comic Sans MS">>I have no criticism of "old" technology
if it is stable and achieves</font>
<br><font face="Comic Sans MS">>learning objectives.</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">And Jim Muller wrote:</font>
<br><font face="Comic Sans MS">>Fascinating statement...but you raise another
question. Why does Logo have</font>
<br><font face="Comic Sans MS">>to be "so much more than it is?"</font>
<br>&nbsp;
<p><font face="Comic Sans MS">>When you see the magic that Logo can add
to a young child's self-literacy,</font>
<br><font face="Comic Sans MS">>what more could you ask for?</font>
<p><font face="Comic Sans MS">I can think of 2 answers:</font>
<p><font face="Comic Sans MS">1. A programming language is something "to
think with". Thinking with sequential procedures and global variables is
what Logo offers. I've been thinking that way since I learned to program
in 1968. But it was wonderful when in 1973 I learned (mostly from an MIT
professor named Carl Hewitt) to think in terms of what he called actors
-- concurrent objects with message passing. Then in 1980 I learned from
Prolog to think of programs declaratively in terms of predicates and theorem
proving. Concurrent Prolog and its sucessors taught me to think with both
actors and logic together. I won't claim that one way of thinking completely
dominates the others. The Logo way of thinking has its place. I just want
to wake up the Logo community to the fact there is much more that can be
"borrowed" from computer science.</font>
<p><font face="Comic Sans MS">2. In 1994 I read an article by Sharon Yoder
in Logo Exchange entitled "Discouraged? ... Don't dispair!". She asked
a class of college freshman about their exposure to Logo. A large percentage
had been exposed and nearly all reported it as a negative experience. In
the 1970s I taught Logo and also saw the results of teaching by others
at the MIT Logo group. It was wonderful. It was "magic". My theory of how
to reconcile these 2 facts is that kids can get a tremendous amount from
learning Logo if taught by a teacher who deeply understands both kids and
programming. I think Sharon's informal survey indicates that such teachers
are rare.</font>
<p><font face="Comic Sans MS">So how can we give kids the power and magic
of programming when such teachers aren't available? By making a software
environment where kids can discover and learn programming on their own.
ToonTalk, I claim, is such an environment. Kids can learn ToonTalk by exploring
a safe self-revealing environment, by working their way through an interactive
puzzle game, by watching narrated demos, by getting help from a software
agent, and more. [I wrote a chapter in a book that was just published this
month on this topic. The book is The Design of Children's Technology, edited
by Alison Druin, published by Morgan Kaufmann]. Early indications are that
this really works (see <a href="http://www.toontalk.com/English/users.htm">www.toontalk.com/English/users.htm</a>).</font>
<p><font face="Comic Sans MS">And Ray wrote:</font>
<br><font face="Comic Sans MS">> Parallel, smarallel - do you really think
the child</font>
<br><font face="Comic Sans MS">>cares how the programs run in the background.</font>
<p><font face="Comic Sans MS">I think I have already partly answered this
in point #1 above. But parallelism isn't just another tool of thinking,
it is also a better way of programming. For example, one of the demos in
ToonTalk is the building of a Ping Pong game. I am convinced that the best
way to structure programs is as many independent (but communicating and
synchronizing) processes. In the Ping Pong example, the ball, the paddle,
and the score keeper are each parallel programs. The world around us is
running in parallel and trying to model or simulate it sequentially is
unnecessarily difficult.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brian Harvey:</font>
<p><font face="Comic Sans MS">"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes:</font>
<br><font face="Comic Sans MS">>But I don't put much value on "coding syntax".
What I do value are the</font>
<br><font face="Comic Sans MS">>underlying concepts -- variables, recursion,
data structures, conditionals,</font>
<br><font face="Comic Sans MS">>etc.</font>
<p><font face="Comic Sans MS">I agree with this, at this broad level of
abstraction.&nbsp; The question is what notation (broadly speaking) makes
the ideas most accessible.&nbsp; Something like a conditional can readily
be represented pictorially.&nbsp; Recursion is a little tougher, because
(I think) in order to make something self-referential it has to have a
name.&nbsp; The best pictorial version I've seen is Radia Perlman's old
"slot machine," in which the procedure names were colors, and were invoked
by colored cards.&nbsp; I find the BBN Function Machines attempt less compelling;
you have to notice that a box inside a box has the same name, which is
really no better than text.&nbsp; I'll be interested to see (tomorrow)
how TT does it -- the documentation without the real program left me quite
confused.</font>
<p><font face="Comic Sans MS">I guess I think text gets a bum rap these
days.&nbsp; We used to have nothing but text, and everyone has overreacted.&nbsp;
Text is still a really expressive medium!&nbsp; Even for emotions, let
alone computer programs.</font>
<br>&nbsp;
<p><font face="Comic Sans MS">> Thinking with</font>
<br><font face="Comic Sans MS">>sequential procedures and global variables
is what Logo offers.</font>
<p><font face="Comic Sans MS">Hey, no fair, Logo has local variables!&nbsp;
But I do agree that there are other valuable programming paradigms.</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Jim Muller:</font>
<p><font face="Comic Sans MS">>(snip)</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>I think Logo is a good thing - it is just
that it could be so much more than</font>
<br><font face="Comic Sans MS">>it is.</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">Ken ==></font>
<p><font face="Comic Sans MS">Fascinating statement...but you raise another
question. Why does Logo have to be "so much more than it is?"</font>
<p><font face="Comic Sans MS">When you see the magic that Logo can add
to a young child's self-literacy, what more could you ask for?</font>
<p><font face="Comic Sans MS">Regards...Jim Muller</font>
<p><font face="Comic Sans MS">Jim Muller THE GREAT LOGO ADVENTURE at <a href="http://www.cyberramp.net/~jmul">http://www.cyberramp.net/~jmul</a></font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Dale R. Reed wrote</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>Ken, I just surfed to your site and ordered
ToonTalk.</font>
<br><font face="Comic Sans MS">> Thanks. I hope you enjoy it.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>I do not like games and I do not find Microworlds
all that much fun.</font>
<br><font face="Comic Sans MS">>It was OK when my little grandsonny lived
nearby and he used to sit on</font>
<br><font face="Comic Sans MS">>my lap and we would create imaginary worlds
with dogs and trees and</font>
<br><font face="Comic Sans MS">>moons but he lives two hours drive away
now and growing up very</font>
<br><font face="Comic Sans MS">>quickly so what I want now is an efficient
and powerful way of</font>
<br><font face="Comic Sans MS">>creating my own designs.</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">I used to enjoy games a lot before I discovered
computer programming. Programming is like a game only more challenging
and more open-ended. While designing ToonTalk, I found games to be a great
source of ideas for how to make things simpler or more fun without watering
them down.</font>
<p><font face="Comic Sans MS">>Something that will force my mind to pay
attention to detail and</font>
<br><font face="Comic Sans MS">>offers me the capability to create something
interesting that Katy and</font>
<br><font face="Comic Sans MS">>I can enjoy.&nbsp; MSWLogo works just fine
for my purposes.&nbsp; I bet I am not</font>
<br><font face="Comic Sans MS">>that much different than many youngsters.</font>
<br><font face="Comic Sans MS">> I think the ability "to create something
interesting" is most important thing about Logo and ToonTalk.</font>
<br>&nbsp;
<p><font face="Comic Sans MS">>But Ken, I like new things and will give
ToonTalk a go.</font>
<p><font face="Comic Sans MS">That's a good attitude.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Bill Kerr:</font>
<p><font face="Comic Sans MS">Ken, Thanks for your interesting post about
ToonTalk. I probably won't have time to have a close look at it for a while
but from the way you are describing it I can't see a lot of difference
from MicroWorlds or other LCSI products like My Make Believe Castle (for
younger kids). When you contrast ToonTalk with Logo you seem to be referring
to older (pre-MicroWorlds) versions of Logo.</font>
<br>&nbsp;
<p><font face="Comic Sans MS">>1. A programming language is something "to
think with". Thinking with</font>
<br><font face="Comic Sans MS">>sequential procedures and global variables
is what Logo offers. I've been</font>
<br><font face="Comic Sans MS">>thinking that way since I learned to program
in 1968. But it was wonderful</font>
<br><font face="Comic Sans MS">>when in 1973 I learned (mostly from an
MIT professor named Carl Hewitt) to</font>
<br><font face="Comic Sans MS">>think in terms of what he called actors
-- concurrent objects with message</font>
<br><font face="Comic Sans MS">>passing.</font>
<p><font face="Comic Sans MS">I have read Papert saying similar things,
eg. in his 'Epistomological Pluralism' article (with Turkle) -- what you
are describing is the philosophy behind MicroWorlds.</font>
<p><font face="Comic Sans MS">Then in 1980 I learned from Prolog to think
of programs</font>
<br><font face="Comic Sans MS">>declaratively in terms of predicates and
theorem proving. Concurrent Prolog</font>
<br><font face="Comic Sans MS">>and its sucessors taught me to think with
both actors and logic together. I</font>
<br><font face="Comic Sans MS">>won't claim that one way of thinking completely
dominates the others. The</font>
<br><font face="Comic Sans MS">>Logo way of thinking has its place. I just
want to wake up the Logo</font>
<br><font face="Comic Sans MS">>community to the fact there is much more
that can be "borrowed" from</font>
<br><font face="Comic Sans MS">>computer science.</font>
<p><font face="Comic Sans MS">the idea of building both logic and intuition
into software, catering for a diversity of learning styles, is also a Papert
idea (eg. same article) and I think this is part of the MicroWorlds design.</font>
<br>&nbsp;
<p><font face="Comic Sans MS">>2. In 1994 I read an article by Sharon Yoder
in Logo Exchange entitled</font>
<br><font face="Comic Sans MS">>"Discouraged? ... Don't dispair!". She
asked a class of college freshman</font>
<br><font face="Comic Sans MS">>about their exposure to Logo. A large percentage
had been exposed and nearly</font>
<br><font face="Comic Sans MS">>all reported it as a negative experience.
In the 1970s I taught Logo and</font>
<br><font face="Comic Sans MS">>also saw the results of teaching by others
at the MIT Logo group. It was</font>
<br><font face="Comic Sans MS">>wonderful. It was "magic". My theory of
how to reconcile these 2 facts is</font>
<br><font face="Comic Sans MS">>that kids can get a tremendous amount from
learning Logo if taught by a</font>
<br><font face="Comic Sans MS">>teacher who deeply understands both kids
and programming. I think Sharon's</font>
<br><font face="Comic Sans MS">>informal survey indicates that such teachers
are rare.</font>
<p><font face="Comic Sans MS">I agree with your analysis here.</font>
<br>&nbsp;
<p><font face="Comic Sans MS">>So how can we give kids the power and magic
of programming when such</font>
<br><font face="Comic Sans MS">>teachers aren't available? By making a
software environment where kids can</font>
<br><font face="Comic Sans MS">>discover and learn programming on their
own. ToonTalk, I claim, is such an</font>
<br><font face="Comic Sans MS">>environment. Kids can learn ToonTalk by
exploring a safe self-revealing</font>
<br><font face="Comic Sans MS">>environment, by working their way through
an interactive puzzle game, by</font>
<br><font face="Comic Sans MS">>watching narrated demos, by getting help
from a software agent, and more. [I</font>
<br><font face="Comic Sans MS">>wrote a chapter in a book that was just
published this month on this topic.</font>
<br><font face="Comic Sans MS">>The book is The Design of Children's Technology,
edited by Alison Druin,</font>
<br><font face="Comic Sans MS">>published by Morgan Kaufmann]. Early indications
are that this really works</font>
<br><font face="Comic Sans MS">>(see <a href="http://www.toontalk.com/English/users.htm">www.toontalk.com/English/users.htm</a>).</font>
<p><font face="Comic Sans MS">This argument is both true and dangerous
IMO. Good constructionist software will be more intuitive for new users
(true) but there will always be a place for good teachers to find diverse
ways to take the user to a higher level. To suggest this might happen through
the software alone is dangerous. (I'd like to chase up your chapter but
no time right now). I think a better solution to the dilemma is to improve
teacher education courses because the human factor will always be the most
important one.</font>
<p><font face="Comic Sans MS">>And Ray wrote:</font>
<br><font face="Comic Sans MS">>> Parallel, smarallel - do you really think
the child</font>
<br><font face="Comic Sans MS">>>cares how the programs run in the background.</font>
<p><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>I think I have already partly answered
this in point #1 above. But</font>
<br><font face="Comic Sans MS">>parallelism isn't just another tool of
thinking, it is also a better way of</font>
<br><font face="Comic Sans MS">>programming. For example, one of the demos
in ToonTalk is the building of a</font>
<br><font face="Comic Sans MS">>Ping Pong game. I am convinced that the
best way to structure programs is as</font>
<br><font face="Comic Sans MS">>many independent (but communicating and
synchronizing) processes. In the</font>
<br><font face="Comic Sans MS">>Ping Pong example, the ball, the paddle,
and the score keeper are each</font>
<br><font face="Comic Sans MS">>parallel programs. The world around us
is running in parallel and trying to</font>
<br><font face="Comic Sans MS">>model or simulate it sequentially is unnecessarily
difficult.</font>
<p><font face="Comic Sans MS">I think what Ray meant is that MicroWorlds
also support parallelism. What you need to show is that TuneTalk somehow
does it better, ie. the difference is somehow obvious to the user not just
to a sophisticated computer scientist. (although I'd be interested in either
explanation personally, ie. an expansion of your earlier very brief explanation).</font>
<p><font face="Comic Sans MS">I'm interested in finding out more about
TuneTalk and its educational philosophy. These brief comments might help
you address some of the thinking you will find in this newsgroup.</font>
<p><font face="Comic Sans MS">-- Bill Kerr</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Gary S. Stager:</font>
<p><font face="Comic Sans MS">Brian,</font>
<p><font face="Comic Sans MS">I had a powerful experience yesterday trying
to use a new "easier" programming environment for kids. Although I was
attempting a very simple task, the clumsiness of the interface required
me to call an old colleague who works for the company that produces the
stuff. The two of us then spent the next hour trying to collaborate on
what should have been a 2 minute program because there was no language
for communicating about our program. "Connect the blue thingy to the corner
of the icon - no not that corner - I said the merge fork..."</font>
<p><font face="Comic Sans MS">One of the powerful ideas of Logo is that
it's sharable. I've recently been reminded of its power by a student of
mine who teaches little Latino kids in L.A. These 3rd grade limited-English
speaking kids are deconstructing projects created by rich NY private middle
school kids and programming (or at least feeling sufficiently confident
that they can attempt to program) their own videogames. Logo offers kids
an environment in which they can create something sharable very early in
their use of the software because it allows for multiple approaches to
solving a problem.</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Gary S. Stager wrote</font>
<br><font face="Comic Sans MS">>I had a powerful experience yesterday trying
to use a new "easier"</font>
<br><font face="Comic Sans MS">>programming environment for kids. Although
I was attempting a very simple</font>
<br><font face="Comic Sans MS">>task, the clumsiness of the interface required
me to call an old</font>
<br><font face="Comic Sans MS">>colleague who works for the company that
produces the stuff. The two of</font>
<br><font face="Comic Sans MS">>us then spent the next hour trying to collaborate
on what should have</font>
<br><font face="Comic Sans MS">>been a 2 minute program because there was
no language for communicating</font>
<br><font face="Comic Sans MS">>about our program. "Connect the blue thingy
to the corner of the icon -</font>
<br><font face="Comic Sans MS">>no not that corner - I said the merge fork..."</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>One of the powerful ideas of Logo is that
it's sharable. ...</font>
<p><font face="Comic Sans MS">Some things like, Logo, are easier to talk
about on a telephone or by email. Not surprising since Logo is textual.
Other things like the software you were using, ToonTalk, and knots are
not so well-suited for purely verbal discussions. Minsky and Papert once
tried to "share" knots over a telephone. They found it extremely difficult.</font>
<p><font face="Comic Sans MS">If you and your colleague had a way to link
your computers so you both saw the same screen and maybe you both had a
mouse cursor for pointing, then talking on the phone might have been very
productive.</font>
<p><font face="Comic Sans MS">But sharability isn't the same as being able
to talk about them on the phone. Things you make in ToonTalk are sharable
- you can even put them in email messages or convert them to Java applets
to show anyone with a web browser what you have made. And these things
are composable -- a very very important feature. Sequential Logo is composable
as well - but I worry how well Microworlds parallel processes compose if
communication is via global variables.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From <a href="mailto:luvisi@andru.sonoma.edu">luvisi@andru.sonoma.edu</a>:</font>
<p><font face="Comic Sans MS">"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes: [snip]</font>
<br><font face="Comic Sans MS">> If you and your colleague had a way to
link your computers so you both saw</font>
<br><font face="Comic Sans MS">> the same screen and maybe you both had
a mouse cursor for pointing, then</font>
<br><font face="Comic Sans MS">> talking on the phone might have been very
productive.</font>
<p><font face="Comic Sans MS">vnc is such a piece of software... <a href="http://www.orl.co.uk/vnc/">http://www.orl.co.uk/vnc/</a></font>
<p><font face="Comic Sans MS">and, like most good software, it's Open Source.</font>
<p><font face="Comic Sans MS">andru</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brian Harvey:</font>
<p><font face="Comic Sans MS">"Bill Kerr" &lt;<a href="mailto:kerrb@senet.com.au">kerrb@senet.com.au</a>>
writes:</font>
<br><font face="Comic Sans MS">> Then in 1980 I learned from Prolog to
think of programs</font>
<br><font face="Comic Sans MS">>>declaratively in terms of predicates and
theorem proving. Concurrent Prolog</font>
<br><font face="Comic Sans MS">>>and its sucessors taught me to think with
both actors and logic together.</font>
<br>&nbsp;
<p><font face="Comic Sans MS">>the idea of building both logic and intuition
into software, catering for a</font>
<br><font face="Comic Sans MS">>diversity of learning styles, is also a
Papert idea (eg. same article) and I</font>
<br><font face="Comic Sans MS">>think this is part of the MicroWorlds design.</font>
<p><font face="Comic Sans MS">This isn't quite fair.&nbsp; Any programming
language requires logical thinking, but Logic Programming is still very
different from procedural programming. The shift in thought processes that's
required is of the same order (though in a different direction) as the
degree to which the massive parallelism in StarLogo is hugely different
from traditional programming, and even from the limited parallelism in
Microworlds.</font>
<p><font face="Comic Sans MS">Ken's quite right that there's nothing in
any flavor of Logo remotely like logic programming.</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">Bill Kerr wrote</font>
<br><font face="Comic Sans MS">> Thanks for your interesting post about
ToonTalk. I probably won't have time</font>
<br><font face="Comic Sans MS">>to have a close look at it for a while
but from the way you are describing</font>
<br><font face="Comic Sans MS">>it I can't see a lot of difference from
MicroWorlds or other LCSI products</font>
<br><font face="Comic Sans MS">>like My Make Believe Castle (for younger
kids). When you contrast ToonTalk</font>
<br><font face="Comic Sans MS">>with Logo you seem to be referring to older
(pre-MicroWorlds) versions of</font>
<br><font face="Comic Sans MS">>Logo.</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">From the point of view of a computer scientist
there are very big differences. They differ both in syntax and semantics.
Logo has a textual syntax. ToonTalk has an animated visual syntax. Logo
is a sequential procedural language. ToonTalk is a concurrent object-oriented
language.&nbsp; My Make Believe Castle is a bit more like ToonTalk but
it is not a general purpose programming language.</font>
<br>&nbsp;
<p><font face="Comic Sans MS">>>1. A programming language is something
"to think with". Thinking with</font>
<br><font face="Comic Sans MS">>>sequential procedures and global variables
is what Logo offers. I've been</font>
<br><font face="Comic Sans MS">>>thinking that way since I learned to program
in 1968. But it was wonderful</font>
<br><font face="Comic Sans MS">>>when in 1973 I learned (mostly from an
MIT professor named Carl Hewitt) to</font>
<br><font face="Comic Sans MS">>>think in terms of what he called actors
-- concurrent objects with message</font>
<br><font face="Comic Sans MS">>>passing.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>I have read Papert saying similar things,
eg. in his 'Epistomological</font>
<br><font face="Comic Sans MS">>Pluralism' article (with Turkle) -- what
you are describing is the</font>
<br><font face="Comic Sans MS">>philosophy behind MicroWorlds.</font>
<br><font face="Comic Sans MS">> I've learned a lot from Seymour - including
this idea. Maybe I'm mistaken, but Microworlds doesn't really change Logo
that much. It adds lots of useful user interface gadgets and a very primitive,
impoverished notion of parallel processing. I am not aware of any way to
synchronize parallel processes in Microworlds. And the only way processes
can communicate is via global variables. This is poor modularity and can
lead to extremely hard to track down bugs. And in what sense is Microworlds
object-oriented?</font>
<br>&nbsp;
<p><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>the idea of building both logic and intuition
into software, catering for a</font>
<br><font face="Comic Sans MS">>diversity of learning styles, is also a
Papert idea (eg. same article) and I</font>
<br><font face="Comic Sans MS">>think this is part of the MicroWorlds design.</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">Logic/planning and intuition/tinkering are
in that article. And I don't question that Microworlds supports both cognitive
styles (as does ToonTalk). But that is a different level than what I was
trying to get at. I was pointing out there is a role for logic and declarative
thinking as a way of EXPRESSING programs, not just designing and building
them.</font>
<p><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>This argument is both true and dangerous
IMO. Good constructionist software</font>
<br><font face="Comic Sans MS">>will be more intuitive for new users (true)
but there will always be a place</font>
<br><font face="Comic Sans MS">>for good teachers to find diverse ways
to take the user to a higher level.</font>
<br><font face="Comic Sans MS">>To suggest this might happen through the
software alone is dangerous. (I'd</font>
<br><font face="Comic Sans MS">>like to chase up your chapter but no time
right now). I think a better</font>
<br><font face="Comic Sans MS">>solution to the dilemma is to improve teacher
education courses because the</font>
<br><font face="Comic Sans MS">>human factor will always be the most important
one.</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">I agree to an extent. But I also see ToonTalk
working in the home where there is no teacher. Seymour's most recent book
"The Connected Family"&nbsp; also emphasizes the learning that happens
at home.</font>
<br>&nbsp;
<p><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>I think what Ray meant is that MicroWorlds
also support parallelism. What</font>
<br><font face="Comic Sans MS">>you need to show is that TuneTalk somehow
does it better, ie. the difference</font>
<br><font face="Comic Sans MS">>is somehow obvious to the user not just
to a sophisticated computer</font>
<br><font face="Comic Sans MS">>scientist. (although I'd be interested
in either explanation personally, ie.</font>
<br><font face="Comic Sans MS">>an expansion of your earlier very brief
explanation).</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">I touched on the sophisticated computer scientist
answer above. I plan to write 1 or 2 page long answer to this soon and
will post it when it is ready.</font>
<br>&nbsp;
<p><font face="Comic Sans MS">>I'm interested in finding out more about
TuneTalk and its educational</font>
<br><font face="Comic Sans MS">>philosophy. These brief comments might
help you address some of the thinking</font>
<br><font face="Comic Sans MS">>you will find in this newsgroup.</font>
<br><font face="Comic Sans MS">> Your comments were helpful, thanks.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Bill Kerr:</font>
<p><font face="Comic Sans MS">Brian wrote:</font>
<br><font face="Comic Sans MS">>Ken's quite right that there's nothing
in any flavor of Logo remotely like</font>
<br><font face="Comic Sans MS">>logic programming.</font>
<p><font face="Comic Sans MS">I know nothing about Prologo so I stand corrected.
My question would be: what is it about ToonTalk&nbsp; logic that is both
obvious and superior to the logic of MicroWorlds? Is this a powerful idea
like recursion that ought to be incorporated into educational software
and that its exclusion make Logo "old technology"? Or is it something which
is mainly of interest to computer scientists but not to a wider audience?
My (admittedly subjective) feeling is that the balance between logic and
intuition in MicroWorlds is about right.</font>
<p><font face="Comic Sans MS">-- Bill Kerr</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brian Harvey:</font>
<p><font face="Comic Sans MS">"Bill Kerr" &lt;<a href="mailto:kerrb@senet.com.au">kerrb@senet.com.au</a>>
writes:</font>
<br><font face="Comic Sans MS">>Brian wrote:</font>
<br><font face="Comic Sans MS">>>Ken's quite right that there's nothing
in any flavor of Logo remotely like</font>
<br><font face="Comic Sans MS">>>logic programming.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>I know nothing about Prologo so I stand
corrected. My question would be:</font>
<br><font face="Comic Sans MS">>what is it about ToonTalk&nbsp; logic that
is both obvious and superior to the</font>
<br><font face="Comic Sans MS">>logic of MicroWorlds? Is this a powerful
idea like recursion that ought to</font>
<br><font face="Comic Sans MS">>be incorporated into educational software
and that its exclusion make Logo</font>
<br><font face="Comic Sans MS">>"old technology"? Or is it something which
is mainly of interest to computer</font>
<br><font face="Comic Sans MS">>scientists but not to a wider audience?
My (admittedly subjective) feeling</font>
<br><font face="Comic Sans MS">>is that the balance between logic and intuition
in MicroWorlds is about</font>
<br><font face="Comic Sans MS">>right.</font>
<p><font face="Comic Sans MS">First of all, forget about that "balance
between logic and intuition" business.&nbsp; Logic programming involves
neither more nor less intuition than procedural programming.</font>
<p><font face="Comic Sans MS">In procedural programming, you tell the computer
an ALGORITHM it will use to compute the answers you want.&nbsp; First do
this, then do that, etc.</font>
<p><font face="Comic Sans MS">In logic programming, you tell the computer
some FACTS that you know, and some RULES that can be used to infer new
facts, and then you ask it questions, and it's the computer's job to figure
out how to get the answers.</font>
<p><font face="Comic Sans MS">As a classic example, here is a Logo procedure
to append two lists:</font>
<p><font face="Comic Sans MS">to append :a :b if empty? :a [output :b]
output fput (first :a) (append bf :a :b) end</font>
<p><font face="Comic Sans MS">By contrast, in logic programming you would
enter these rules:</font>
<p><font face="Comic Sans MS">(append [] :b) = :b</font>
<p><font face="Comic Sans MS">IF (append :a :b) = :c THEN (append (fput
:x :a) :b) = (fput :x :c)</font>
<p><font face="Comic Sans MS">(This isn't really any particular logic language;
I'm trying to use Logo vocabulary and notation to avoid making notation
an issue.) With these rules, as with a Logo procedure, you can as questions
like</font>
<p><font face="Comic Sans MS">What is (append [1 2 3] [4 5])?</font>
<p><font face="Comic Sans MS">but you can also ask questions like</font>
<p><font face="Comic Sans MS">If (append [1 2 3] :x) is [1 2 3 4 5], what
is :x?</font>
<p><font face="Comic Sans MS">or even</font>
<p><font face="Comic Sans MS">If (append :x :y) is [1 2 3 4 5], what are
:x and :y?</font>
<p><font face="Comic Sans MS">which will give you all six possible answers!&nbsp;
In Logo, you can't "run a procedure backwards" as you can the rules in
a logic language.</font>
<p><font face="Comic Sans MS">The way it works is that the inventors of
logic programming invented a sort of universal algorithm, a generalization
of pattern matching.</font>
<p><font face="Comic Sans MS">Logic programming is a natural fit for data
base querying; it's less obvious as a fit for side-effect-laden programming,
although many years ago Ken Kahn wrote a turtle graphics package in Prolog,
so his current interests have a long history.</font>
<p><font face="Comic Sans MS">Logic programming really is quite a different
way of thinking about programming, and it does, I think, stretch the mind
usefully, whether or not one is a computer scientist.&nbsp; Using Prolog
as a first language for kids has a pretty long history, not in the US but
definitely in England -- Richard Ennals wrote a Prolog-for-kids book, I
think some time in the 1970s but all my books are still in cartons so I
can't look it up right now.&nbsp; (I just moved!)</font>
<p><font face="Comic Sans MS">Executive summary:&nbsp; I don't think Logo
is *obsolete*, but I do think that there are more than one good computer
tool for kids!</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Bill Kerr:</font>
<p><font face="Comic Sans MS">Brian Harvey wrote:</font>
<br><font face="Comic Sans MS">>Logic programming really is quite a different
way of thinking about</font>
<br><font face="Comic Sans MS">>programming, and it does, I think, stretch
the mind usefully, whether</font>
<br><font face="Comic Sans MS">>or not one is a computer scientist.&nbsp;
Using Prolog as a first language</font>
<br><font face="Comic Sans MS">>for kids has a pretty long history, not
in the US but definitely in</font>
<br><font face="Comic Sans MS">>England -- Richard Ennals wrote a Prolog-for-kids
book,</font>
<p><font face="Comic Sans MS">Thanks for your informative response -- it
sounds like Prolog might be a good way to give meaning to the concept of
reverse engineering.</font>
<p><font face="Comic Sans MS">-- Bill Kerr</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Bill Kerr:</font>
<p><font face="Comic Sans MS">Ken Kahn wrote:</font>
<br><font face="Comic Sans MS">> Maybe I'm mistaken,</font>
<br><font face="Comic Sans MS">>but Microworlds doesn't really change Logo
that much. It adds lots of useful</font>
<br><font face="Comic Sans MS">>user interface gadgets and a very primitive,
impoverished notion of parallel</font>
<br><font face="Comic Sans MS">>processing. I am not aware of any way to
synchronize parallel processes in</font>
<br><font face="Comic Sans MS">>Microworlds.</font>
<p><font face="Comic Sans MS">I think this MicroWorlds procedure (from
MW help on waituntil and also done?) does synchronise parallel processes:</font>
<p><font face="Comic Sans MS">to sq-circ</font>
<br><font face="Comic Sans MS">t1, pd launch [repeat 36 [fd 10 rt 10]]</font>
<br><font face="Comic Sans MS">; t1 draws a circle</font>
<br><font face="Comic Sans MS">t2, pd launch [repeat 4 [fd 50 rt 90]]</font>
<br><font face="Comic Sans MS">; t2 draws a square</font>
<br><font face="Comic Sans MS">waituntil [done? [repeat 36 [fd 10 rt 10]]]</font>
<br><font face="Comic Sans MS">; the procedure does not continue until
the circle is finished</font>
<br><font face="Comic Sans MS">; so that the drawings of circles and square
are synchronised</font>
<br><font face="Comic Sans MS">t1, pu rt random 360 fd random 50</font>
<br><font face="Comic Sans MS">t2, pu rt random 360 fd random 50</font>
<br><font face="Comic Sans MS">; repositions turtles for next drawing</font>
<br><font face="Comic Sans MS">sq-circ</font>
<br><font face="Comic Sans MS">end</font>
<p><font face="Comic Sans MS">>And the only way processes can communicate
is via global</font>
<br><font face="Comic Sans MS">>variables. This is poor modularity and
can lead to extremely hard to track</font>
<br><font face="Comic Sans MS">>down bugs. And in what sense is Microworlds
object-oriented?</font>
<p><font face="Comic Sans MS">MicroWorlds has a turtlesown primitive that
enables you to localise things like the speed or reset position of a turtle
which is, for instance, simulating a horse. I'll paste in the MW help explanation
here, which will give us some sort of starting point for further discussion.
I'm not trying to suggest that MW is fully object orientated but code can
reside on objects such as colours, turtles, buttons. This gives students
an introduction to elementary oops concepts and for young kids I can't
see the point in going beyond that. MW and logo has local variables which
would be the main thing, wouldn't it? My main impression from doing a little
bit of java oops earlier this year is that everything is 10 times harder
than in using logo.</font>
<p><font face="Comic Sans MS">&lt;start of paste from MW help></font>
<br><font face="Comic Sans MS">turtlesown word</font>
<p><font face="Comic Sans MS">Assigns a variable to all the turtles in
the current project. This variable can then be set to a specific value
for each turtle. This command also creates a new primitive made of the
word set followed by the name of the variable (e.g., turtlesown "speed
creates a setspeed command as in t1, setspeed 12). There are two ways to
get the value of a given turtle variable: you can talk to a turtle and
use the variable name to report the value (e.g., t1, show speed displays
12 in this example) or you can use the turtle name followed by 's (e.g.,
show t1's "speed displays 12).</font>
<p><font face="Comic Sans MS">Use remove to remove a turtle variable. This
removes the named variable for all the turtles in the project. After a
turtlesown instruction, the value of the variable is set to the empty list
(see the first three lines in the example below).</font>
<br><font face="Comic Sans MS">Example:</font>
<p><font face="Comic Sans MS">turtlesown "speed</font>
<br><font face="Comic Sans MS">t1, show speed</font>
<br><font face="Comic Sans MS">(empty list)</font>
<br><font face="Comic Sans MS">t1, setspeed 10</font>
<br><font face="Comic Sans MS">t2, setspeed 20</font>
<br><font face="Comic Sans MS">t3, setspeed 5</font>
<br><font face="Comic Sans MS">t1, show speed</font>
<br><font face="Comic Sans MS">10</font>
<br><font face="Comic Sans MS">show t2's "speed</font>
<br><font face="Comic Sans MS">20</font>
<br><font face="Comic Sans MS">everyone [fd speed]</font>
<br><font face="Comic Sans MS">everyone [forever [fd speed]]</font>
<p><font face="Comic Sans MS">Choose Stop All from the Edit menu.</font>
<p><font face="Comic Sans MS">remove "speed</font>
<br><font face="Comic Sans MS">&lt;end of paste from MW help></font>
<p><font face="Comic Sans MS">-- Bill Kerr</font>
<br><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Bill Kerr wrote in message &lt;000201be183d$78328100$9cfc98cb@kerrb>...</font>
<br><font face="Comic Sans MS">>Ken Kahn wrote:</font>
<br><font face="Comic Sans MS">>>I am not aware of any way to synchronize
parallel processes in Microworlds.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>I think this MicroWorlds procedure (from
MW help on waituntil and also</font>
<br><font face="Comic Sans MS">>done?) does synchronise parallel processes:</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>to sq-circ</font>
<br><font face="Comic Sans MS">>t1, pd launch [repeat 36 [fd 10 rt 10]]</font>
<br><font face="Comic Sans MS">>; t1 draws a circle</font>
<br><font face="Comic Sans MS">>t2, pd launch [repeat 4 [fd 50 rt 90]]</font>
<br><font face="Comic Sans MS">>; t2 draws a square</font>
<br><font face="Comic Sans MS">>waituntil [done? [repeat 36 [fd 10 rt 10]]]</font>
<br><font face="Comic Sans MS">>; the procedure does not continue until
the circle is finished</font>
<br><font face="Comic Sans MS">>; so that the drawings of circles and square
are synchronised</font>
<br><font face="Comic Sans MS">>t1, pu rt random 360 fd random 50</font>
<br><font face="Comic Sans MS">>t2, pu rt random 360 fd random 50</font>
<br><font face="Comic Sans MS">>; repositions turtles for next drawing</font>
<br><font face="Comic Sans MS">>sq-circ</font>
<br><font face="Comic Sans MS">>end</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">I stand corrected, thanks. This is a kind
of control flow synchronization since it waits until the processes spawned
for t1 and t2 have terminated. Or does "waituntil [done?" wait until all
processes have terminated? Does MicroWorlds also have process synchronization
based upon data? So, for example, a consumer process of some data waits
until the generator has generated it? Note that in general the generator
need not have terminated, it may just be reporting back results as it finds
them (e.g. a web search engine). ToonTalk only has data synchronization
but that is the more general kind of synchronization, since one can set
data (in ToonTalk give a bird a token) indicating that the process is just
terminating.</font>
<p><font face="Comic Sans MS">By the way, is there a MicroWorlds manual
on the web somewhere?</font>
<p><font face="Comic Sans MS">>>And the only way processes can communicate
is via global</font>
<br><font face="Comic Sans MS">>>variables. This is poor modularity and
can lead to extremely hard to track</font>
<br><font face="Comic Sans MS">>>down bugs. And in what sense is Microworlds
object-oriented?</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>MicroWorlds has a turtlesown primitive
that enables you to localise things</font>
<br><font face="Comic Sans MS">>like the speed or reset position of a turtle
which is, for instance,</font>
<br><font face="Comic Sans MS">>simulating a horse. I'll paste in the MW
help explanation here, which will</font>
<br><font face="Comic Sans MS">>give us some sort of starting point for
further discussion. I'm not trying</font>
<br><font face="Comic Sans MS">>to suggest that MW is fully object orientated
but code can reside on</font>
<br><font face="Comic Sans MS">objects</font>
<br><font face="Comic Sans MS">>such as colours, turtles, buttons. This
gives students an introduction to</font>
<br><font face="Comic Sans MS">>elementary oops concepts and for young
kids I can't see the point in going</font>
<br><font face="Comic Sans MS">>beyond that. MW and logo has local variables
which would be the main thing,</font>
<br><font face="Comic Sans MS">>wouldn't it? My main impression from doing
a little bit of java oops</font>
<br><font face="Comic Sans MS">earlier</font>
<br><font face="Comic Sans MS">>this year is that everything is 10 times
harder than in using logo.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>&lt;start of paste from MW help></font>
<br><font face="Comic Sans MS">>turtlesown word</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>Assigns a variable to all the turtles in
the current project. This variable</font>
<br><font face="Comic Sans MS">>can then be set to a specific value for
each turtle. This command also</font>
<br><font face="Comic Sans MS">>creates a new primitive made of the word
set followed by the name of the</font>
<br><font face="Comic Sans MS">>variable (e.g., turtlesown "speed creates
a setspeed command as in t1,</font>
<br><font face="Comic Sans MS">>setspeed 12).</font>
<br><font face="Comic Sans MS">>There are two ways to get the value of
a given turtle variable: you can</font>
<br><font face="Comic Sans MS">talk</font>
<br><font face="Comic Sans MS">>to a turtle and use the variable name to
report the value (e.g., t1, show</font>
<br><font face="Comic Sans MS">>speed displays 12 in this example) or you
can use the turtle name followed</font>
<br><font face="Comic Sans MS">>by 's (e.g., show t1's "speed displays
12).</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>Use remove to remove a turtle variable.
This removes the named variable for</font>
<br><font face="Comic Sans MS">>all the turtles in the project.</font>
<br><font face="Comic Sans MS">>After a turtlesown instruction, the value
of the variable is set to the</font>
<br><font face="Comic Sans MS">>empty list (see the first three lines in
the example below).</font>
<br><font face="Comic Sans MS">>Example:</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>turtlesown "speed</font>
<br><font face="Comic Sans MS">>t1, show speed</font>
<br><font face="Comic Sans MS">> (empty list)</font>
<br><font face="Comic Sans MS">>t1, setspeed 10</font>
<br><font face="Comic Sans MS">>t2, setspeed 20</font>
<br><font face="Comic Sans MS">>t3, setspeed 5</font>
<br><font face="Comic Sans MS">>t1, show speed</font>
<br><font face="Comic Sans MS">>10</font>
<br><font face="Comic Sans MS">>show t2's "speed</font>
<br><font face="Comic Sans MS">>20</font>
<br><font face="Comic Sans MS">>everyone [fd speed]</font>
<br><font face="Comic Sans MS">>everyone [forever [fd speed]]</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>Choose Stop All from the Edit menu.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>remove "speed</font>
<br><font face="Comic Sans MS">>&lt;end of paste from MW help></font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">To me, and many others, the essence of the
idea of an object is that it joins local data and behavior. You ask a object
to move and whether it walks, swims, or flies depends upon the kind of
object it is and what "move" methods have been associated with it. "turtlesown"
does give objects some local data (but it is odd that every object in the
system has the same set of local variables). But behavior is critical.
(I don't happen to think inheritance is critical, though it is often quite
nice.)</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn (<a href="http://www.toontalk.com/">www.toontalk.com</a>)</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Bill Kerr:</font>
<p><font face="Comic Sans MS">>By the way, is there a MicroWorlds manual
on the web somewhere?</font>
<p><font face="Comic Sans MS">I think you can download a demo copy of MW,
with manual, from <a href="http://www.microworlds.com/">www.microworlds.com</a></font>
<p><font face="Comic Sans MS">>To me, and many others, the essence of the
idea of an object is that it</font>
<br><font face="Comic Sans MS">>joins local data and behavior. You ask
a object to move and whether it</font>
<br><font face="Comic Sans MS">>walks, swims, or flies depends upon the
kind of object it is and what</font>
<br><font face="Comic Sans MS">"move"</font>
<br><font face="Comic Sans MS">>methods have been associated with it. "turtlesown"
does give objects some</font>
<br><font face="Comic Sans MS">>local data (but it is odd that every object
in the system has the same set</font>
<br><font face="Comic Sans MS">>of local variables). But behavior is critical.
(I don't happen to think</font>
<br><font face="Comic Sans MS">>inheritance is critical, though it is often
quite nice.)</font>
<p><font face="Comic Sans MS">I sort of understand what you are getting
at. From my Java course I recall that this is called polymorphism. I'll
have to wait until I have some more time for a closer look at ToonTalk
to try to evaluate your comments on both data synchronization and aspects</font>
<br><font face="Comic Sans MS">of OOPs that ought to be incorporated into
kids software. Thanks for the prompt responses to my queries.</font>
<p><font face="Comic Sans MS">-- Bill Kerr</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Wen Su:</font>
<p><font face="Comic Sans MS">I think that, if my understanding is correct,
there is a major difference between MW and TT here. Suppose in the code
below, both subprocesses (called Circle and Square) that are launched try
to modify a variable owned by the current process (called Parent), in MW,
there is no directly built-in mechanism that allows the Parent process
to tell which launched process</font>
<br><font face="Comic Sans MS">modifies the variable first, for example.
Of course, this can be done by users by other means. The same issue arised
in low-level hardware driver code, or when both the interrupt handler code
(the code that is triggered to be executed by a hardware interrupt event)
and the main line code try to modify the same variable. In TT, the data
change requests are sent from</font>
<br><font face="Comic Sans MS">Circle and Square to Parent and the requests
are placed in a queue, and the Parent process can tell which data modification
request comes in first by means of its built-in message passing method(bird).</font>
<p><font face="Comic Sans MS">This above comment (if correct), does not
imply that MW is inferior as far as its education value is concerned, IMHO.
Maybe MW developers happen to believe this feature is not that important
for children students. Some people (Ken Kahn?) may believe this is very
very important ( I think that is the reason why he talked about the "global
variable" accessing issue.); some may not.</font>
<p><font face="Comic Sans MS">Regards,</font>
<br><font face="Comic Sans MS">Wen</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Wen provided a good example in MicroWorlds
of my point about the dangers of concurrency in languages with shared state
(the variable owned by the Parent process in his posting). Thanks.</font>
<p><font face="Comic Sans MS">His question is about how important this
issue is. It would not surprise me if many readers of this news group have
taught MicroWorlds for years and never seen a kid run across it. Why should
we care? One reason is the principle that we shouldn't give kids programming
tools that us adults wouldn't use. nother reason is that kids that do get
ambitious and may start to explore what kinds of parallel programming they
can do in MicroWorlds will run up across these problems. These problems
are very hard for professional programmers to detect, track down, and fix.
And even worse is that MicroWorlds doesn't give its users the tools to
deal with these problems (locks or critical regions, for example).</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn (<a href="http://www.toontalk.com/">www.toontalk.com</a>)</font>
<br><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brian Harvey:</font>
<p><font face="Comic Sans MS">"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes:</font>
<br><font face="Comic Sans MS">> And even worse</font>
<br><font face="Comic Sans MS">>is that MicroWorlds doesn't give its users
the tools to deal with these</font>
<br><font face="Comic Sans MS">>problems (locks or critical regions, for
example).</font>
<p><font face="Comic Sans MS">I don't know what MW does, but StarLogo tries
to guarantee correct results without making the user aware of synchronization
issues, by, for example, always guaranteeing that in an IF, the test and
the first action in the conditional instruction sequence are done atomically.</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Brian Harvey wrote in message &lt;73pgqn$h6$1@agate.berkeley.edu>...</font>
<p><font face="Comic Sans MS">>I don't know what MW does, but StarLogo
tries to guarantee correct</font>
<p><font face="Comic Sans MS">>results without making the user aware of
synchronization issues, by,</font>
<p><font face="Comic Sans MS">>for example, always guaranteeing that in
an IF, the test and the first</font>
<p><font face="Comic Sans MS">>action in the conditional instruction sequence
are done atomically.</font>
<p><font face="Comic Sans MS">That probably works fine in a SIMD language
like StarLogo. But atomicity is dangerous in general, since it can lead
to deadlock. Here, if the conditional test is a procedure call then that
procedure may in turn access something that has been locked by this hidden
atomicity rule. And then progress stops.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn (www.toontalk.com)</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Tom Woods:</font>
<p><font face="Comic Sans MS">Hello,</font>
<p><font face="Comic Sans MS">To me, textual programming enables students
to express their thoughts in ways similar to spoken language. Reading,
writing, speaking and listening are necessarily serial. This is not a bad
thing.</font>
<p><font face="Comic Sans MS">Although I'm not familiar with ToonTalk,
I can imagine visual programming as being akin to other creative visual
processes. In the visual arts the presence of a language is undeniable.
With it, artists can express rich parallel thoughts through images. Neither
is this a bad thing.</font>
<p><font face="Comic Sans MS">I worry about any implication that one form
is inferior to another which is the message I got when it was said that
Logo is "old technology." Both forms of expression are important. One is
not inferior to another -- just different.</font>
<p><font face="Comic Sans MS">For those of you who may remember my much
more active presence on the list a couple years ago, hello again. I finished
school and wound up in jail. Don't worry, they let me out at the end of
the day. I have the wonderfully creative task of starting a school where
nothing existed before. One thing I hope to do soon is have my some of
my students build computers out of salvaged components and get into programming.
Most of the discussions here seem to involve children. Does anyone have
any experience using Logo with adult students?</font>
<p><font face="Comic Sans MS">Regards,</font>
<p><font face="Comic Sans MS">Tom Woods</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Tom &amp; Adele Woods wrote</font>
<p><font face="Comic Sans MS">>To me, textual programming enables students
to express their thoughts in</font>
<br><font face="Comic Sans MS">>ways similar to spoken language. Reading,
writing, speaking and listening</font>
<br><font face="Comic Sans MS">>are necessarily serial. This is not a bad
thing.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>Although I'm not familiar with ToonTalk,
I can imagine visual programming as</font>
<br><font face="Comic Sans MS">>being akin to other creative visual processes.
In the visual arts the</font>
<br><font face="Comic Sans MS">>presence of a language is undeniable. With
it, artists can express rich</font>
<br><font face="Comic Sans MS">>parallel thoughts through images. Neither
is this a bad thing.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>I worry about any implication that one
form is inferior to another which is</font>
<br><font face="Comic Sans MS">>the message I got when it was said that
Logo is "old technology." Both forms</font>
<br><font face="Comic Sans MS">>of expression are important. One is not
inferior to another -- just different.</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">I agree, text is good. But as I wrote in
another branch of this thread regarding whether some programming paradigms
are superior to others -- there is a need to prioritize here. If a teacher
is going to teach just one language in a course should it be a visual or
textual one? If a parent is buying a programming language for their children,
which language is the best first language? In an ideal world I would love
to see children learn both kinds of languages. (And also both sequential
procedural languages and concurrent object-oriented ones.)</font>
<p><font face="Comic Sans MS">Maybe I should rephrase the question of Logo's
obsolescence as "Is Logo still the best as the first programming language
children learn?" I don't believe so. I think visual/animated languages
are more appealing to children and easier to learn. I think concurrent
object-oriented languages provide a more natural and more powerful thinking
tool than sequential procedural languages.</font>
<p><font face="Comic Sans MS">If one agrees with me, then the next question
is whether Logo is the best second language to learn. I feel less strongly
about this issue but wonder whether a child who has mastered ToonTalk might
not be ready for Java or Scheme instead.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brian Harvey:</font>
<p><font face="Comic Sans MS">"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes:</font>
<br><font face="Comic Sans MS">> I think visual/animated languages are
more appealing to children</font>
<br><font face="Comic Sans MS">>and easier to learn.</font>
<p><font face="Comic Sans MS">IMHO the best solution to this problem is
a hybrid system, in which things that are easily expressed graphically
can be, but also, anything can be expressed textually.&nbsp; Mike Eisenberg's
SchemePaint is still the best example of what I mean.&nbsp; There are the
standard paint program point-and-click tools, but you can also write Scheme
programs, and in fact you can make new point-and-click tools by implementing
them as Scheme programs.</font>
<p><font face="Comic Sans MS">Microworlds is a decent attempt by the Logo
community to build something along these lines, although it's far from
perfect.&nbsp; (I am measuring perfection right now only on the issue of
the interchangeability of text and graphics interfaces.)</font>
<p><font face="Comic Sans MS">Maybe ToonTalk is, too, since you say that
it produces Java code.&nbsp; If the Java code isn't too convoluted (I haven't
yet had a chance to play with it -- I'll try to do that soon!) and if you
can use Java code to create new capabilities in the GUI, then I'll be pleased.</font>
<p><font face="Comic Sans MS">Btw, to say that concurrency is "natural"
for people raises a lot of questions for me.&nbsp; Indeed, I believe that
if you're simulating a world of independent actors, it feels natural to
program them separately. But my CS students certainly don't find natural
the synchronization problems that arise if those actors want to share state!</font>
<p><font face="Comic Sans MS">(And finally, you and others have mentioned
that different people have different learning styles; part of mine happens
to be that I don't really want to make animations, and I'm more likely
to want to know how many combinations a Simplex lock has.&nbsp; I guess
I'm weird.&nbsp; :-)</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Brian Harvey wrote</font>
<br><font face="Comic Sans MS">>IMHO the best solution to this problem
is a hybrid system, in which</font>
<br><font face="Comic Sans MS">>things that are easily expressed graphically
can be, but also, anything</font>
<br><font face="Comic Sans MS">>can be expressed textually.</font>
<p><font face="Comic Sans MS">I think this is a great research topic. But
I worry about the compromises that would be needed to make this work well
for a general-purpose programming language. And I also am uncertain about
whether hybrids adds some kind of cognitive complexity. On the other hand,
it is always a good thing to be able to see or understand the same thing
in multiple ways.</font>
<p><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>Maybe ToonTalk is, too, since you say that
it produces Java code.&nbsp; If</font>
<br><font face="Comic Sans MS">>the Java code isn't too convoluted (I haven't
yet had a chance to play</font>
<br><font face="Comic Sans MS">>with it -- I'll try to do that soon!) and
if you can use Java code to</font>
<br><font face="Comic Sans MS">>create new capabilities in the GUI, then
I'll be pleased.</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">The Java code is readable but not the kind
of code one would write from scratch. Making it possible to change the
Java code and have that reflected back into ToonTalk is a very difficult
problem.</font>
<p><font face="Comic Sans MS">>Btw, to say that concurrency is "natural"
for people raises a lot of</font>
<br><font face="Comic Sans MS">>questions for me.&nbsp; Indeed, I believe
that if you're simulating a world</font>
<br><font face="Comic Sans MS">>of independent actors, it feels natural
to program them separately.</font>
<br><font face="Comic Sans MS">>But my CS students certainly don't find
natural the synchronization</font>
<br><font face="Comic Sans MS">>problems that arise if those actors want
to share state!</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">I agree if the sharing of state is "direct"
rather than via message passing. That's why I keep complaining about global
variables as the only means of communication in MicroWorlds. I'll write
a longer essay on this issue soon and post it here.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brian Harvey:</font>
<p><font face="Comic Sans MS">"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes:</font>
<br><font face="Comic Sans MS">>The Java code is readable but not the kind
of code one would write from</font>
<br><font face="Comic Sans MS">>scratch. Making it possible to change the
Java code and have that reflected</font>
<br><font face="Comic Sans MS">>back into ToonTalk is a very difficult
problem.</font>
<p><font face="Comic Sans MS">I'm not asking for that.&nbsp; I'm asking
to be able to write, in Java, a new gizmo, let's say a different kind of
magic wand, or a new menu item, or whatever, and integrate that into the
TT world.</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Bob Gorman:</font>
<p><font face="Comic Sans MS">At 11/18/98 05:24 AM -0800, Brian Harvey
wrote:</font>
<br><font face="Comic Sans MS">>I guess I think text gets a bum rap these
days.&nbsp; We used to have nothing</font>
<p><font face="Comic Sans MS">>but text, and everyone has overreacted.&nbsp;
Text is still a really expressive medium!</font>
<p><font face="Comic Sans MS">Even for emotions, let alone computer programs.
I whole-heartily agree. We have a left brain, which enjoys text, and a
right brain which enjoys pictures. While so many competitive arguments
try to prove that their favorite side is "better", I would simply reply,
there is nothing with using BOTH! Indeed, I sometimes group people into
4 categories: Right brain dominant, Left brain dominant, Both brain dominant,
and of course, neither!</font>
<p><font face="Comic Sans MS">Bob</font>
<p><font face="Comic Sans MS">"To get <font color="#FF0000">NEW </font><font color="#0000FF">Answers,
you must ask </font><font color="#FF0000">NEW </font><font color="#0000FF">Questions!"
- </font><font color="#FF0000">Bob </font><font color="#0000FF">Gorman</font></font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Dale R. Reed:</font>
<p><font face="Comic Sans MS">Bob Gorman wrote:</font>
<br><font face="Comic Sans MS">>We have a left brain, which enjoys text,
and a right brain which enjoys pictures.</font>
<p><font face="Comic Sans MS">I enjoy text(poetry, novels) that create
pictures in the mind.&nbsp; For instance I like to read Victor Hugo.</font>
<p><font face="Comic Sans MS">With Logo I can use text to create pictures
that are not exactly as I thought they would be.</font>
<p><font face="Comic Sans MS">I can suprise myself.&nbsp;&nbsp; I like
that.</font>
<p><font face="Comic Sans MS">Dale --- $ <a href="mailto:dale-reed@worldnet.att.net">dale-reed@worldnet.att.net</a>&nbsp;
Seattle, Washington U.S.A. $</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">&nbsp;&nbsp;&nbsp; Bob Gorman wrote&nbsp;&nbsp;&nbsp;&nbsp;
We have a left brain, which enjoys text, and a right brain which enjoys
pictures. While so many competitive arguments try to prove that their favorite
side is "better", I would simply reply, there is nothing with using BOTH!</font>
<p><font face="Comic Sans MS">&nbsp;&nbsp;&nbsp; Some people are called
"visual thinkers" because they seem to be good at solving visual problems
and they report using visual imagery when thinking. For these people, textual
programming languages are difficult. Visual thinkers would probably both
prefer visual programming languages and also be more effective in using
them than textual languages. Other people seem to prefer text and symbols.
Maybe ToonTalk isn't so appropriate for them. A hybrid textual-visual language
might satisfy both kinds of thinkers, but it might not. Compromises are
needed to make a good hybrid. And hybrids tend to be more complex and much
harder to engineer.&nbsp;&nbsp;&nbsp;&nbsp; I suspect that kids, particularly
younger ones, are more visual and less textual/symbolic in their thinking.
I know that these categories are crude and overly simplistic but I think
they are useful ways of thinking about these issues.&nbsp;&nbsp;&nbsp;&nbsp;
Does anyone know of psychological research on these questions?</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">ken kahn</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brian Harvey:</font>
<p><font face="Comic Sans MS">"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes:</font>
<br><font face="Comic Sans MS">> Compromises are needed to make a good
hybrid.</font>
<p><font face="Comic Sans MS">No, no!&nbsp; Compromises make a bad hybrid.&nbsp;
Syntheses are needed for a good one. (I learned this in Marxism class.)&nbsp;
Compromise would be like those old "macro" systems for the Mac that recorded
mouse clicks in pixel coordinates.</font>
<p><font face="Comic Sans MS">So for example, take that exchange-two-values
thing you did in TT the other night.&nbsp; Does the corresponding Java
code look like pixels, or does it look like the way you'd program an exchange
directly in Java?&nbsp; (Well, I guess it can't, exactly, but I'd settle
for exch(a, b) where exch is a procedure you supply that finds a nice vacant
part of the screen.)</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Brian Harvey wrote</font>
<br><font face="Comic Sans MS">>No, no!&nbsp; Compromises make a bad hybrid.&nbsp;
Syntheses are needed for a good</font>
<br><font face="Comic Sans MS">one.</font>
<br><font face="Comic Sans MS">>(I learned this in Marxism class.)&nbsp;
Compromise would be like those old</font>
<br><font face="Comic Sans MS">"macro"</font>
<br><font face="Comic Sans MS">>systems for the Mac that recorded mouse
clicks in pixel coordinates.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">I'll agree with that (despite seldom agreeing
with Marxism).</font>
<p><font face="Comic Sans MS">>So for example, take that exchange-two-values
thing you did in TT the other</font>
<br><font face="Comic Sans MS">>night.&nbsp; Does the corresponding Java
code look like pixels, or does it look</font>
<br><font face="Comic Sans MS">>like the way you'd program an exchange
directly in Java?&nbsp; (Well, I guess it</font>
<br><font face="Comic Sans MS">>can't, exactly, but I'd settle for exch(a,
b) where exch is a procedure you</font>
<br><font face="Comic Sans MS">>supply that finds a nice vacant part of
the screen.)</font>
<p><font face="Comic Sans MS">Somewhere inbetween. Here's the untouched
automatically generated Java program from having trained a robot to swap
2 numbers if they are out of order. A great project (any grad students
out there lurking?) is to build a tool that transform the following Java
code into something more normal. My guess is that a good partial evaluator
could do the job.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn (<a href="http://www.toontalk.com/">www.toontalk.com</a>)</font>
<p><font face="Comic Sans MS">import ap.toontalk.*;</font>
<br><font face="Comic Sans MS">class Robot_P extends TTRobot {</font>
<br><font face="Comic Sans MS">Robot_P(TTNotebook n) {</font>
<br><font face="Comic Sans MS">&nbsp; notebook = n;</font>
<br><font face="Comic Sans MS">}</font>
<br><font face="Comic Sans MS">public TTObject gets(TTObject given) throws
TTException {</font>
<br><font face="Comic Sans MS">&nbsp; if (!wants.matches(given)) return
null;</font>
<br><font face="Comic Sans MS">&nbsp; // If given a box that matches the
box in his thought bubble (called "wants"),</font>
<br><font face="Comic Sans MS">&nbsp; // this robot will do the following.</font>
<br><font face="Comic Sans MS">&nbsp; TTObject hand;</font>
<br><font face="Comic Sans MS">&nbsp; TTObject temp1;</font>
<br><font face="Comic Sans MS">&nbsp; // pick up what's in the first hole
inside his box</font>
<br><font face="Comic Sans MS">&nbsp; hand = given.pickUp(0);</font>
<br><font face="Comic Sans MS">&nbsp; // drop it</font>
<br><font face="Comic Sans MS">&nbsp; temp1 = hand;</font>
<br><font face="Comic Sans MS">&nbsp; // pick up what's in the third hole
inside his box</font>
<br><font face="Comic Sans MS">&nbsp; hand = given.pickUp(2);</font>
<br><font face="Comic Sans MS">&nbsp; // drop it on the first hole inside
his box</font>
<br><font face="Comic Sans MS">&nbsp; given.holeGets(0, hand);</font>
<br><font face="Comic Sans MS">&nbsp; // pick up the last thing he made
or found</font>
<br><font face="Comic Sans MS">&nbsp; hand = temp1;</font>
<br><font face="Comic Sans MS">&nbsp; // drop it on the third hole inside
his box</font>
<br><font face="Comic Sans MS">&nbsp; given.holeGets(2, hand);</font>
<br><font face="Comic Sans MS">&nbsp; return this;&nbsp; // This robot
has finished and will see if the box still matches his thoughts and try
again.</font>
<br><font face="Comic Sans MS">}</font>
<br><font face="Comic Sans MS">}</font>
<br><font face="Comic Sans MS">public class Applet_P extends TTApplet {</font>
<br><font face="Comic Sans MS">public static void main(String args[]) {</font>
<br><font face="Comic Sans MS">&nbsp; new TTFrame().begin(new Applet_P());</font>
<br><font face="Comic Sans MS">}</font>
<br><font face="Comic Sans MS">public void initialize() {</font>
<br><font face="Comic Sans MS">&nbsp; TTNotebook notebook = TT.NOTEBOOK;</font>
<br><font face="Comic Sans MS">&nbsp; box = new TTBox(3);</font>
<br><font face="Comic Sans MS">&nbsp; box.setHole(0, new TTInteger(2, '+'));</font>
<br><font face="Comic Sans MS">&nbsp; box.setHole(1, new TTScale('>'));</font>
<br><font face="Comic Sans MS">&nbsp; box.setHole(2, new TTInteger(1, '+'));</font>
<br><font face="Comic Sans MS">&nbsp; // We just made a box with 3 holes.
The first hole contains the number 2. The</font>
<br><font face="Comic Sans MS">&nbsp; // second hole contains a scale tipped
to the left. The third hole contains</font>
<br><font face="Comic Sans MS">&nbsp; // the number 1.</font>
<br><font face="Comic Sans MS">&nbsp; robot = new Robot_P(notebook);</font>
<br><font face="Comic Sans MS">&nbsp; TTBox wants1 = new TTBox(3);</font>
<br><font face="Comic Sans MS">&nbsp; // This robot will only accept a
box with 3 holes. The first hole contains</font>
<br><font face="Comic Sans MS">&nbsp; // any number. The second hole contains
a scale tipped to the left. The third</font>
<br><font face="Comic Sans MS">&nbsp; // hole contains any number.</font>
<br><font face="Comic Sans MS">&nbsp; wants1.setHole(0, TT.BLANK_NUMBER);</font>
<br><font face="Comic Sans MS">&nbsp; wants1.setHole(1, new TTScale('>'));</font>
<br><font face="Comic Sans MS">&nbsp; wants1.setHole(2, TT.BLANK_NUMBER);</font>
<br><font face="Comic Sans MS">&nbsp; robot.setWants(wants1);</font>
<br><font face="Comic Sans MS">&nbsp; team = new TTTeam(box, robot);</font>
<br><font face="Comic Sans MS">&nbsp; setStartingTeam(team);</font>
<br><font face="Comic Sans MS">&nbsp; displayThis(box);</font>
<br><font face="Comic Sans MS">}</font>
<br><font face="Comic Sans MS">}</font>
<br><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brian Harvey:</font>
<p><font face="Comic Sans MS">"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes:</font>
<br><font face="Comic Sans MS">>&nbsp; hand = given.pickUp(0);</font>
<br><font face="Comic Sans MS">>&nbsp; temp1 = hand;</font>
<br><font face="Comic Sans MS">>&nbsp; hand = given.pickUp(2);</font>
<br><font face="Comic Sans MS">>&nbsp; given.holeGets(0, hand);</font>
<br><font face="Comic Sans MS">>&nbsp; hand = temp1;</font>
<br><font face="Comic Sans MS">>&nbsp; given.holeGets(2, hand);</font>
<p><font face="Comic Sans MS">Decent!&nbsp; I'm impressed.&nbsp; Would
it work without "hand"?&nbsp; I mean, if we changed the Java code to</font>
<p><font face="Comic Sans MS">&nbsp; temp1 = given.pickUp(0);</font>
<br><font face="Comic Sans MS">&nbsp; given.holeGets(0, given.pickUp(2));</font>
<br><font face="Comic Sans MS">&nbsp; given.holeGets(2, temp1);</font>
<p><font face="Comic Sans MS">would it animate in some decent way?&nbsp;
(Imho that would include just having it all happen in a flash -- as long
as it doesn't blow up or leave confetti on the screen or something.)</font>
<p><font face="Comic Sans MS">If this sort of thing works, it opens the
door for the kind of text-mode programmability that I (following Eisenberg)
want.</font>
<p><font face="Comic Sans MS">[Too bad it's Java with all that fluff about
Public blah blah... :-)</font>
<p><font face="Comic Sans MS">If only it were Logo, this would be perfect.]</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Brian Harvey wrote</font>
<br><font face="Comic Sans MS">>Decent!&nbsp; I'm impressed.&nbsp; Would
it work without "hand"?&nbsp; I mean, if</font>
<br><font face="Comic Sans MS">>we changed the Java code to</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>&nbsp; temp1 = given.pickUp(0);</font>
<br><font face="Comic Sans MS">>&nbsp; given.holeGets(0, given.pickUp(2));</font>
<br><font face="Comic Sans MS">>&nbsp; given.holeGets(2, temp1);</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>would it animate in some decent way?&nbsp;
(Imho that would include just</font>
<br><font face="Comic Sans MS">>having it all happen in a flash -- as long
as it doesn't blow up or</font>
<br><font face="Comic Sans MS">>leave confetti on the screen or something.)</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">That should work. And a little "peephole
optimizer" could probably automatically generate it.</font>
<p><font face="Comic Sans MS">But I should clarify that the Java applet
doesn't show ToonTalk programming environment graphics. In this case you
don't see the hand when running as an Applet. If, on the other hand, you
build a graphical application inside of ToonTalk (e.g. the Ping Pong game
example), then those graphics will be transferred to Java.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn (<a href="http://www.toontalk.com/">www.toontalk.com</a>)</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Tom Woods:</font>
<p><font face="Comic Sans MS">Ken Kahn wrote:</font>
<p><font face="Comic Sans MS">>I agree, text is good. But as I wrote in
another branch of this thread</font>
<br><font face="Comic Sans MS">>regarding whether some programming paradigms
are superior to others -- there</font>
<br><font face="Comic Sans MS">>is a need to prioritize here. If a teacher
is going to teach just one</font>
<br><font face="Comic Sans MS">>language in a course should it be a visual
or textual one?</font>
<p><font face="Comic Sans MS">Part of the key to this issue is the definition
of "superior," and that depends on your priorities.</font>
<p><font face="Comic Sans MS">My priorities: 1. Give students rich and
varied opportunities to express their thoughts verbally, visually, auditorially,
and kinesthetically. 2. Give students opportunities to think about how
they think.</font>
<p><font face="Comic Sans MS">Because programming languages are among the
things that offer possibilities in these two areas, I'm interested in exploring
ways they can be included in students' learning. If I had to ask a question
like you did above, I would ask, If a teacher is going to teach just one
language, what will best meet the needs of the students?" I like the answer
Brian Harvey stated:</font>
<br>&nbsp;
<p><font face="Comic Sans MS">>IMHO the best solution to this problem is
a hybrid system, in which</font>
<br><font face="Comic Sans MS">>things that are easily expressed graphically
can be, but also, anything</font>
<br><font face="Comic Sans MS">>can be expressed textually.</font>
<p><font face="Comic Sans MS">Tom Woods</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Tom &amp; Adele Woods wrote in message &lt;<a href="mailto:1.5.4.32.19981123051027.006dbdd4@moose.ncia.net">1.5.4.32.19981123051027.006dbdd4@moose.ncia.net</a>>...</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>My priorities:</font>
<br><font face="Comic Sans MS">>1. Give students rich and varied opportunities
to express their thoughts</font>
<br><font face="Comic Sans MS">>verbally, visually, auditorially, and kinesthetically.</font>
<p><font face="Comic Sans MS">I find this a very exciting idea to pursue.
In this discussion I have been emphasizing ToonTalk's visual/animated nature.
These other sensory modalities are important and I have made steps in that
direction. ToonTalk makes heavy use of sound effects. More interestingly,
it uses both canned speech and a text-to-speech engine. If you have a force-feedback
joystick (these cost about $100 these days), then when you use ToonTalk
you feel the vibrations of the helicopter engine, or the wall when you
walk into it, or the weight of something in your hand. Within the next
9 months I plan to integrate speech input into ToonTalk.</font>
<p><font face="Comic Sans MS">Maybe it doesn't need to be said to this
audience, but these modalities should be available for kids to use in their
own creations. For example, ToonTalk not only uses force-feedback but gives
kids the option of including force effects in their own programs. Ditto
for sound effects and text-to-speech. And speech input when it is done.</font>
<p><font face="Comic Sans MS">I don't claim to have the answers for how
to best use and integrate these varied modalities. There is room for basic
research, as well as a variety of engineering efforts, to explore these
issues.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn (<a href="http://www.toontalk.com/">www.toontalk.com</a>)</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Tom Woods:</font>
<p><font face="Comic Sans MS">Wen Su wrote:</font>
<p><font face="Comic Sans MS">>To express their thoughts verbally using
computers is still not</font>
<br><font face="Comic Sans MS">>much different than using pencils and papers,
as our previous</font>
<br><font face="Comic Sans MS">>generation did.</font>
<p><font face="Comic Sans MS">Very true. The pencil is a "letter quality
printer." Nor is visual expression on a computer vastly different from
painting or drawing. I wouldn't want to forsake the pencil and brush for
a computer. Students would benefit from exposure to all the tools, I feel.</font>
<p><font face="Comic Sans MS">>I hesitate to be a "nay-sayer" here. But
although it is very</font>
<br><font face="Comic Sans MS">>good to give students a multimedia construction
tool so that</font>
<br><font face="Comic Sans MS">>they can express their thoughts in these
new multimedia tools,</font>
<br><font face="Comic Sans MS">>most tools today are still not easy enough
to use for youngsters</font>
<br><font face="Comic Sans MS">>(or even for adults.)</font>
<p><font face="Comic Sans MS">Again true... for the pencil and brush as
well. Just ask a student if writing is easy. Just try to paint a picture
and get it just the way you want.</font>
<br>&nbsp;
<p><font face="Comic Sans MS">Tom Woods</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Tom Woods:</font>
<p><font face="Comic Sans MS">Ken Kahn wrote:</font>
<br><font face="Comic Sans MS">> In this discussion I have been</font>
<br><font face="Comic Sans MS">>emphasizing ToonTalk's visual/animated
nature. These other sensory</font>
<br><font face="Comic Sans MS">>modalities are important...</font>
<p><font face="Comic Sans MS">NOW you're talkin' When you get the speech
working, will you have equivalent text too? That would be extremely beneficial
for emerging and early readers who often start by reading words they have
written or spoken themselves. You might be on to something big.</font>
<p><font face="Comic Sans MS">Tom Woods</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Bill Kerr:</font>
<p><font face="Comic Sans MS">Ken Kahn wrote:</font>
<br><font face="Comic Sans MS">I agree most people like what they already
know. This might mean that teachers won't give ToonTalk the chance it deserves.</font>
<p><font face="Comic Sans MS">and also in another post replying to Tom
Woods:</font>
<p><font face="Comic Sans MS">Maybe I should rephrase the question of Logo's
obsolescence as "Is Logo still the best as the first programming language
children learn?" I don't believe so. I think visual/animated languages
are more appealing to children and easier to learn. I think concurrent
object-oriented languages provide a more natural and more powerful thinking
tool than sequential procedural languages.</font>
<p><font face="Comic Sans MS">---------------------------------</font>
<p><font face="Comic Sans MS">I like the way you have rephrased your challenge
to Logo, which makes it more likely I'll get around to looking at ToonTalk,
when I get time from writing reports</font>
<p><font face="Comic Sans MS">With regard to teachers giving TT the chance
it deserves: this made me think of something in a book on "Learning in
Science" by Osborne &amp; Freyberg (it's a book about Childrens Science),
which I just looked up to refresh my memory, I quote:</font>
<p><font face="Comic Sans MS">"Ideas lose status as they become less intelligible,
plausible and fruitful. Conversely, new ideas increase in status as they
become more intelligible, more plausible and more fruitful." (48) [they
write more about exactly what they mean by these terms]</font>
<p><font face="Comic Sans MS">Although I have invested a lot of time in
MicroWorlds and it rates well on these 3 criteria I think I should have
a hard look at your alternative. It would be foolish to think that Logo/MicroWorlds/next
evolution will *always* be the&nbsp; best first language for kids. From
other perspectives I see other problems, however:</font>
<p><font face="Comic Sans MS">my perspective: the trial you are organising
is a comparison with Superlogo not MicroWorlds (I don't know much about
Superlogo)</font>
<p><font face="Comic Sans MS">your perspective (mine too): the actual market
for kids programming languages seems to be shrinking, as more sophisticated
pre-packed simulations, like sim-life etc. come on stream.</font>
<p><font face="Comic Sans MS">-- Bill Kerr</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">Ken Kahn then posted <a href="concur.htm">an
essay</a> on "Logo with parallel processes vs. ToonTalk".</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brian Harvey:</font>
<p><font face="Comic Sans MS">"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes:</font>
<br><font face="Comic Sans MS">>In the recent discussion about Logo and
ToonTalk, one of the issues was</font>
<br><font face="Comic Sans MS">>about concurrency. I promised a longer
response to the question about</font>
<br><font face="Comic Sans MS">>whether the parallelism supported by MicroWorlds
is as good as what ToonTalk</font>
<br><font face="Comic Sans MS">>offers. Here's my 7 paragraph long answer:</font>
<p><font face="Comic Sans MS">This is really helpful!&nbsp; Now I think
I can articulate where we differ.</font>
<p><font face="Comic Sans MS">>The lack of subroutines in ToonTalk makes
it much more feasible to have much</font>
<br><font face="Comic Sans MS">>larger number of processes than conventional
programming languages. The</font>
<br><font face="Comic Sans MS">>reason for this is that everyone implements
subroutine calls using a data</font>
<br><font face="Comic Sans MS">>structure called a stack. Stacks are a
very effective way of implementing</font>
<br><font face="Comic Sans MS">>procedural calls, including recursive calls.
The problem is that each</font>
<br><font face="Comic Sans MS">>process needs its own stack. This makes
processes somewhat costly. I've</font>
<br><font face="Comic Sans MS">>tested ToonTalk with tens of thousands
of houses (i.e. processes). In</font>
<br><font face="Comic Sans MS">>contrast, when I used Java, it stopped
working when I had just a couple</font>
<br><font face="Comic Sans MS">>hundred processes.</font>
<p><font face="Comic Sans MS">I don't understand this.&nbsp; If the processes
were doing embedded recursion, so that you really need to keep all the
state of all the procedure calls around, then I don't understand how you're
avoiding it.&nbsp; If your complaint is that the Java stack grows on tail
calls, then the problem isn't with subroutines, but with inferior language
implementations. Use Berkeley Logo instead!&nbsp; It does correct tail
call elimination.</font>
<p><font face="Comic Sans MS">>Conventional languages have shared state.
The same variables, data</font>
<br><font face="Comic Sans MS">>structures, and objects can be accessed
from different processes (processes</font>
<br><font face="Comic Sans MS">>that share data are often called threads).
Sharing state is necessary in</font>
<br><font face="Comic Sans MS">>these languages in order for threads to
work together.</font>
<p><font face="Comic Sans MS">Ah, now I see why you keep (incorrectly)
saying "global variables" when describing the alleged limitations of Logo.&nbsp;
Your concern is not with the scope of the variables but with the sharing
across processes. But (and this is the main point I want to make here)
there is another way to harness concurrency without running into synchronization
errors: functional programming!&nbsp; Race conditions are possible only
if the various threads are reassigning values to variables.&nbsp; But there's
no need ever to do that.&nbsp; (In Logo terms, you never need to use MAKE.)
When you lump functional programming in with sequential programming, I
think you're not really doing justice to the power of procedure calling
as a control mechanism. Some computations really lend themselves to the
imperative model of programming you describe.&nbsp; But what about the
classic Logo example of English sentence generation?&nbsp; I think this
is best described as a composition of functions.&nbsp; And even if the
arguments to functions are computed concurrently, there is no synchronization
problem. Now, in a way, you DO provide for function calling, with the birds
and stuff.&nbsp; But I think that, because you deprecate the idea, your
metaphor makes function calling much more complicated than it should be.&nbsp;
I still don't see why every function call should HAVE to be a separate
process -- maybe because I don't understand what you're saying about stack
space.&nbsp; Are you saying that separate processes ensure no mutation
of shared variables?&nbsp; Couldn't you achieve the same thing by not allowing
robots (procedures, I take it) to mutate things outside of themselves?</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Brian Harvey wrote</font>
<br><font face="Comic Sans MS">>I don't understand this.&nbsp; If the processes
were doing embedded recursion,</font>
<br><font face="Comic Sans MS">>so that you really need to keep all the
state of all the procedure calls</font>
<br><font face="Comic Sans MS">>around, then I don't understand how you're
avoiding it.&nbsp; If your</font>
<br><font face="Comic Sans MS">>complaint is that the Java stack grows
on tail calls, then the problem</font>
<br><font face="Comic Sans MS">>isn't with subroutines, but with inferior
language implementations.</font>
<br><font face="Comic Sans MS">>Use Berkeley Logo instead!&nbsp; It does
correct tail call elimination.</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">I agree that procedural languages should
do tail recursion optimization. But I was trying to make another point.
ToonTalk could be implemented as a un-ordered collection of process records.
A process record is like a stack frame - it contains a pointer to the code
(robots in ToonTalk) and an argument vector (a box in ToonTalk). To be
fairer to conventional languages, while ToonTalk has very cheap processes,
ordinary procedure calls are more costly since they use the heap rather
than a stack. But the fact that stacks are not used is why process spawning,
suspension, and termination are very cheap operations in ToonTalk.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>But (and this is the main point I want
to make here) there is another</font>
<br><font face="Comic Sans MS">>way to harness concurrency without running
into synchronization errors:</font>
<br><font face="Comic Sans MS">>functional programming!&nbsp; Race conditions
are possible only if the</font>
<br><font face="Comic Sans MS">>various threads are reassigning values
to variables.&nbsp; But there's no</font>
<br><font face="Comic Sans MS">>need ever to do that.&nbsp; (In Logo terms,
you never need to use MAKE.)</font>
<br><font face="Comic Sans MS">>When you lump functional programming in
with sequential programming,</font>
<br><font face="Comic Sans MS">>I think you're not really doing justice
to the power of procedure</font>
<br><font face="Comic Sans MS">>calling as a control mechanism.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>Some computations really lend themselves
to the imperative model of</font>
<br><font face="Comic Sans MS">>programming you describe.&nbsp; But what
about the classic Logo example</font>
<br><font face="Comic Sans MS">>of English sentence generation?&nbsp; I
think this is best described as</font>
<br><font face="Comic Sans MS">>a composition of functions.&nbsp; And even
if the arguments to functions</font>
<br><font face="Comic Sans MS">>are computed concurrently, there is no
synchronization problem.</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">I agree that in programs without side-effects
as in functional programming all my objections and concerns about synchronization
disappear. And I agree some nice programs can be written in a pure functional
style, e.g. your sentence generator. But (and this is my main point here)
there are too many programs that cannot be written as pure functions. The
bank account example I gave earlier is one. Or a score keeper in a game.
Or most simulations, animations, games, etc. Even programs that do I/O
are hard to fit into the pure functional framework.</font>
<p><font face="Comic Sans MS">>Now, in a way, you DO provide for function
calling, with the birds</font>
<br><font face="Comic Sans MS">>and stuff.&nbsp; But I think that, because
you deprecate the idea, your</font>
<br><font face="Comic Sans MS">>metaphor makes function calling much more
complicated than it</font>
<br><font face="Comic Sans MS">>should be.&nbsp; I still don't see why
every function call should HAVE to</font>
<br><font face="Comic Sans MS">>be a separate process -- maybe because
I don't understand what</font>
<br><font face="Comic Sans MS">>you're saying about stack space.&nbsp;
Are you saying that separate processes</font>
<br><font face="Comic Sans MS">>ensure no mutation of shared variables?&nbsp;
Couldn't you achieve the same</font>
<br><font face="Comic Sans MS">>thing by not allowing robots (procedures,
I take it) to mutate things</font>
<br><font face="Comic Sans MS">>outside of themselves?</font>
<p><font face="Comic Sans MS">I would rather say I provide a programming
technique or pattern of ToonTalk usage that corresponds exactly to function
calling. And I admit it is a bit more complicated when all you want to
do is function calling. But I claim you want something more general than
function calling. Suppose you want to return 2 items? In ToonTalk you just
put 2 birds in the box and as the values are computed they are given to
the birds and their corresponding nests get filled. Suppose you don't want
a single value but a stream of answers. Maybe even an infinite stream (e.g.
the Sieve of Erathosthenes prime number generator). Suppose you want to
create a network of cooperating agents. And why should one try to force
message passing between objects to fit into the framework of function calling?</font>
<p><font face="Comic Sans MS">We may be losing all but the serious programmers
and computer scientists on this list, but I think this is a good thread.
I'm learning how to be clearer about what I'm doing.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn (<a href="http://www.toontalk.com/">www.toontalk.com</a>)</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brian Harvey:</font>
<p><font face="Comic Sans MS">"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes:</font>
<br><font face="Comic Sans MS">> But the fact that stacks</font>
<br><font face="Comic Sans MS">>are not used is why process spawning, suspension,
and termination are very</font>
<br><font face="Comic Sans MS">>cheap operations in ToonTalk.</font>
<p><font face="Comic Sans MS">I still don't get it, I'm afraid; why is
a frame on the stack more expensive than a frame on the heap?&nbsp; Is
this some PC-specific thing I don't know about?</font>
<p><font face="Comic Sans MS">>I would rather say I provide a programming
technique or pattern of ToonTalk</font>
<br><font face="Comic Sans MS">>usage that corresponds exactly to function
calling. And I admit it is a bit</font>
<br><font face="Comic Sans MS">>more complicated when all you want to do
is function calling. But I claim</font>
<br><font face="Comic Sans MS">>you want something more general than function
calling. Suppose you want to</font>
<br><font face="Comic Sans MS">>return 2 items?</font>
<p><font face="Comic Sans MS">Interesting -- we are having just that argument
right now over on comp.lang.scheme; the implementor types have put in multiple
return values for efficiency reasons, and the lambda fans hate it.</font>
<p><font face="Comic Sans MS">But I don't want to make you do everything
functionally.&nbsp; What I want is a language that doesn't impose one paradigm
on me, but allows me to choose what's best for the problem at hand.&nbsp;
So, it's not that I want you to leave anything out; I want you to make
function composition easier, also!</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Brian Harvey wrote</font>
<br><font face="Comic Sans MS">>I still don't get it, I'm afraid; why is
a frame on the stack more</font>
<br><font face="Comic Sans MS">>expensive than a frame on the heap? Is
this some PC-specific thing</font>
<br><font face="Comic Sans MS">>I don't know about?</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">I'm sorry, I'm not being clear. Let me start
again.</font>
<p><font face="Comic Sans MS">In procedural language implementations, when
a procedure is called (non-tail recursively) a frame or record is pushed
onto a stack. Each thread or process needs its own stack. When a thread
suspends all the memory devoted to the stack is tied up until the process
resumes and the procedure calls unwind.</font>
<p><font face="Comic Sans MS">In ToonTalk and related languages, the only
memory that a process needs is for 2 pointers: to the program (robots)
and to the data (box). There is no stack. There is no other state. That
is the point I was trying to make.</font>
<p><font face="Comic Sans MS">Because of this 100,000 processes in ToonTalk
is feasible. (The default city size only holds 400 houses but the largest
size holds about a 250,000 houses.) What is a reasonable upper limit for
the number of processes in Logo?</font>
<p><font face="Comic Sans MS">Some reader may wonder why this matters for
kids? Massive parallelism has been shown to useful when kids use StarLogo.
In ToonTalk we can have parallelism to the same scale as StarLogo but MIMD
(multiple instructions multiple data), not the much more limitted SIMD
(single instruction multiple data) of StarLogo. ToonTalk enables one to
put a few processes behind each pixel on the screen if you want.</font>
<p><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>But I don't want to make you do everything
functionally. What I want</font>
<br><font face="Comic Sans MS">>is a language that doesn't impose one paradigm
on me, but allows me</font>
<br><font face="Comic Sans MS">>to choose what's best for the problem at
hand. So, it's not that I</font>
<br><font face="Comic Sans MS">>want you to leave anything out; I want
you to make function composition</font>
<br><font face="Comic Sans MS">>easier, also!</font>
<p><font face="Comic Sans MS">But your argument about why concurrency is
harmless in functional languages doesn't generalize to the multiple paradigm
language you are suggesting. If you don't do everything functionally then
concurrency is dangerous and complex. Unless you do things the way ToonTalk
does.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brian Harvey:</font>
<p><font face="Comic Sans MS">"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes:</font>
<br><font face="Comic Sans MS">>In procedural language implementations,
when a procedure is called (non-tail</font>
<br><font face="Comic Sans MS">>recursively) a frame or record is pushed
onto a stack. Each thread or</font>
<br><font face="Comic Sans MS">>process needs its own stack. When a thread
suspends all the memory devoted</font>
<br><font face="Comic Sans MS">>to the stack is tied up until the process
resumes and the procedure calls</font>
<br><font face="Comic Sans MS">>unwind.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>In ToonTalk and related languages, the
only memory that a process needs is</font>
<br><font face="Comic Sans MS">>for 2 pointers: to the program (robots)
and to the data (box). There is no</font>
<br><font face="Comic Sans MS">>stack. There is no other state. That is
the point I was trying to make.</font>
<p><font face="Comic Sans MS">I still don't see the point. If you take
a computation that is naturally expressed as ONE PROCESS with 100,000 procedure
calls, and instead make it 100,000 processes, each with (in effect) one
procedure call, you haven't saved any storage. If Logo would have needed
100,000 procedure calls, it's because there are 100,000 pieces of saved
state needed for the computation.</font>
<br><font face="Comic Sans MS">Why does it matter whether those 100,000
frames are on one stack or divided among 100,000 processes?</font>
<p><font face="Comic Sans MS">If you're saying that you can't have 100,000
processes each doing 100,000 procedure calls, then I agree -- but that's
not a fair argument. Logo doesn't do that. No language does that.</font>
<p><font face="Comic Sans MS">Maybe I should put it this way: Instead of
100,000 stack frames, you have 100,000 bird nests. (If you're not using
birds, then you are doing something that would be a tail call in Logo,
and it's not going to grow the stack.)</font>
<p><font face="Comic Sans MS">>But your argument about why concurrency
is harmless in functional languages</font>
<br><font face="Comic Sans MS">>doesn't generalize to the multiple paradigm
language you are suggesting. If</font>
<br><font face="Comic Sans MS">>you don't do everything functionally then
concurrency is dangerous and</font>
<br><font face="Comic Sans MS">>complex. Unless you do things the way ToonTalk
does.</font>
<p><font face="Comic Sans MS">That's why I proposed a compromise: Allow
a process to mutate only its own private variables. So as long as you avoid
mutation you can have shared data.</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Brian Harvey wrote</font>
<br><font face="Comic Sans MS">>I still don't see the point. If you take
a computation that is naturally</font>
<br><font face="Comic Sans MS">>expressed as ONE PROCESS with 100,000 procedure
calls, and instead make it</font>
<br><font face="Comic Sans MS">>100,000 processes, each with (in effect)
one procedure call, you haven't</font>
<br><font face="Comic Sans MS">>saved any storage. If Logo would have needed
100,000 procedure calls, it's</font>
<br><font face="Comic Sans MS">>because there are 100,000 pieces of saved
state needed for the computation.</font>
<br><font face="Comic Sans MS">>Why does it matter whether those 100,000
frames are on one stack or</font>
<br><font face="Comic Sans MS">>divided among 100,000 processes?</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>If you're saying that you can't have 100,000
processes each doing 100,000</font>
<br><font face="Comic Sans MS">>procedure calls, then I agree -- but that's
not a fair argument. Logo</font>
<br><font face="Comic Sans MS">>doesn't do that. No language does that.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>Maybe I should put it this way: Instead
of 100,000 stack frames, you have</font>
<br><font face="Comic Sans MS">>100,000 bird nests. (If you're not using
birds, then you are doing</font>
<br><font face="Comic Sans MS">something</font>
<br><font face="Comic Sans MS">>that would be a tail call in Logo, and
it's not going to grow the stack.)</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">100,000 houses. Bird nests are only needed
if a computation in a house needs to receive data or requests from other
houses.</font>
<p><font face="Comic Sans MS">And yes, languages like ToonTalk can have
100,000 processes each doing procedure calls. I just tried to fill a ToonTalk
city with 160,000 houses (it started getting too slow and paging too much
after 50,000). In every house a robot is working away counting (they needn't
be doing the same thing - I'm just lazy). If you want to try it yourself,
change the city size to 200 (that is 200x200 blocks where each block holds
4 houses). You can find a remote control for the size of your city in the
Options notebook. Then train a robot to get the robot that repeatedly adds
1 and load him in a truck together with a box with a 1 in it. If you are
patient enough you can then just let that robot start up the other 159,999
processes but once some of those processes start working that robot won't
get a time slice very often. So train another robot to drop copies of the
robot you trained into a truck. Wait a few minutes and then start flying
around the city visiting houses.</font>
<p><font face="Comic Sans MS">Why would kids want so many processes? Because
I think each object should be a process. And I believe that kids think
so to. The idea of objects that are "dead" unless they are processing some
message from the outside is strange, even if it is the way C++, Java, Object
Logo, etc. work.</font>
<p><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>That's why I proposed a compromise: Allow
a process to mutate only its</font>
<br><font face="Comic Sans MS">>own private variables. So as long as you
avoid mutation you can have</font>
<br><font face="Comic Sans MS">>shared data.</font>
<p><font face="Comic Sans MS">So are objects private to a process? How
do they communicate between processes? Or is it that the instance variables
of the objects are private to the process, but object references are global?</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn</font>
<br><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brian Harvey:</font>
<p><font face="Comic Sans MS">"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes:</font>
<br><font face="Comic Sans MS">>And yes, languages like ToonTalk can have
100,000 processes each doing</font>
<br><font face="Comic Sans MS">>procedure calls.</font>
<p><font face="Comic Sans MS">Now I'm really lost. You argued that procedure
calling is bad because they require stack frames, whereas processes are
good because they don't. I asked, why does it matter whether state information
is on a stack or in a heap -- either you need the state information, in
which case it doesn't matter where you store it, or you don't need it,
in which case it certainly doesn't matter where you don't store it. You
were proposing parallelism as an alternative to composition of functions.
And I still don't see why parallelism requires less storage than composition
of functions.</font>
<p><font face="Comic Sans MS">>So are objects private to a process? How
do they communicate between</font>
<br><font face="Comic Sans MS">>processes? Or is it that the instance variables
of the objects are private</font>
<br><font face="Comic Sans MS">>to the process, but object references are
global?</font>
<p><font face="Comic Sans MS">Data that belongs to an object shouldn't
be a problem; the object is in charge of that data, and it ensures the
atomicity of requests to use the data, which it can do because it exports
the methods to access the data. It's data not belonging to an object that
we have to worry about.</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Brian Harvey wrote in message &lt;<a href="mailto:73ph80$lp$1@agate.berkeley.edu">73ph80$lp$1@agate.berkeley.edu</a>>...</font>
<br><font face="Comic Sans MS">>"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes:</font>
<br><font face="Comic Sans MS">>>And yes, languages like ToonTalk can have
100,000 processes each doing</font>
<br><font face="Comic Sans MS">>>procedure calls.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>Now I'm really lost. You argued that procedure
calling is bad because</font>
<br><font face="Comic Sans MS">>they require stack frames, whereas processes
are good because they don't.</font>
<br><font face="Comic Sans MS">>I asked, why does it matter whether state
information is on a stack or</font>
<br><font face="Comic Sans MS">>in a heap -- either you need the state
information, in which case it</font>
<br><font face="Comic Sans MS">>doesn't matter where you store it, or you
don't need it, in which case</font>
<br><font face="Comic Sans MS">>it certainly doesn't matter where you don't
store it. You were proposing</font>
<br><font face="Comic Sans MS">>parallelism as an alternative to composition
of functions. And I still</font>
<br><font face="Comic Sans MS">>don't see why parallelism requires less
storage than composition of</font>
<br><font face="Comic Sans MS">>functions.</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">One reason for your confusion is that I probably
shouldn't have used the</font>
<br><font face="Comic Sans MS">word "procedure calls" above. Maybe repeatedly
excuting a block of</font>
<br><font face="Comic Sans MS">instructions might have been a better way
to say it. They are not each</font>
<br><font face="Comic Sans MS">executing a procedure that in turn calls
any other procedures.</font>
<p><font face="Comic Sans MS">The stack vs. heap issue isn't the main point
but let me try to clarify it.</font>
<br><font face="Comic Sans MS">A stack is typically implemented as a block
of memory. If the stack grows</font>
<br><font face="Comic Sans MS">too deep, then either a larger block needs
to be allocated and the</font>
<br><font face="Comic Sans MS">information needs to be copied over or the
another block of memory needs to</font>
<br><font face="Comic Sans MS">be allocated and linked into the original
stack. If the heap is used (either</font>
<br><font face="Comic Sans MS">as in ToonTalk or as alternative way of
implementing a stack), then there is</font>
<br><font face="Comic Sans MS">nothing corresponding to the unused portion
of the block of memory allocated</font>
<br><font face="Comic Sans MS">for a stack. When the number of processes
or threads is in the thousands or</font>
<br><font face="Comic Sans MS">hundreds of thousands this can be an important
issue. If you expect typical</font>
<br><font face="Comic Sans MS">programs to have tens or hundreds of threads
then a stack is a more</font>
<br><font face="Comic Sans MS">efficient data structure than using the
heap. My point is that all</font>
<br><font face="Comic Sans MS">sequential languages with threads that I'm
aware of are implemented with</font>
<br><font face="Comic Sans MS">stacks. Hence a low limit on the number
of processes that are practical.</font>
<p><font face="Comic Sans MS">On the main point, let's consider a program
like this. (Excuse me if I make</font>
<br><font face="Comic Sans MS">any syntax mistakes, it has been a very
long time since I've written a Logo</font>
<br><font face="Comic Sans MS">program.)</font>
<p><font face="Comic Sans MS">to a</font>
<br><font face="Comic Sans MS">b</font>
<br><font face="Comic Sans MS">c</font>
<br><font face="Comic Sans MS">end</font>
<p><font face="Comic Sans MS">to b</font>
<br><font face="Comic Sans MS">d</font>
<br><font face="Comic Sans MS">e</font>
<br><font face="Comic Sans MS">end</font>
<p><font face="Comic Sans MS">to d</font>
<br><font face="Comic Sans MS">some code that causes this process to suspend</font>
<br><font face="Comic Sans MS">end</font>
<p><font face="Comic Sans MS">Then when d suspends the stack of a -> b
-> d needs to be kept until d</font>
<br><font face="Comic Sans MS">finishes.</font>
<p><font face="Comic Sans MS">The equivalent situation in ToonTalk is that
b and c are spawned. b causes d</font>
<br><font face="Comic Sans MS">and e to be spawned. d suspends but there
is no stack to be saved.</font>
<p><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>Data that belongs to an object shouldn't
be a problem; the object is</font>
<br><font face="Comic Sans MS">>in charge of that data, and it ensures
the atomicity of requests to</font>
<br><font face="Comic Sans MS">>use the data, which it can do because it
exports the methods to access</font>
<br><font face="Comic Sans MS">>the data. It's data not belonging to an
object that we have to worry</font>
<br><font face="Comic Sans MS">about.</font>
<p><font face="Comic Sans MS">This seems very close to what Java does.
A method can be declared</font>
<br><font face="Comic Sans MS">"synchronized" so it is atomic. This can
easily lead to deadlocks. I don't</font>
<br><font face="Comic Sans MS">know how frequently it will if kids are
programming in such a language.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn (<a href="http://www.toontalk.com/">www.toontalk.com</a>)</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brian Harvey:</font>
<p><font face="Comic Sans MS">"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes:</font>
<br><font face="Comic Sans MS">>to a</font>
<br><font face="Comic Sans MS">>b</font>
<br><font face="Comic Sans MS">>c</font>
<br><font face="Comic Sans MS">>end</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>to b</font>
<br><font face="Comic Sans MS">>d</font>
<br><font face="Comic Sans MS">>e</font>
<br><font face="Comic Sans MS">>end</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>to d</font>
<br><font face="Comic Sans MS">>some code that causes this process to suspend</font>
<br><font face="Comic Sans MS">>end</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>Then when d suspends the stack of a ->
b -> d needs to be kept until d</font>
<br><font face="Comic Sans MS">>finishes.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>The equivalent situation in ToonTalk is
that b and c are spawned. b causes d</font>
<br><font face="Comic Sans MS">>and e to be spawned. d suspends but there
is no stack to be saved.</font>
<p><font face="Comic Sans MS">If in fact c can't run until it gets a result
from b, then instead of a lot</font>
<br><font face="Comic Sans MS">of stack frames you have a lot of waiting
spawned threads, which also take</font>
<br><font face="Comic Sans MS">some state. Or, if all your threads really
can run concurrently, you have</font>
<br><font face="Comic Sans MS">saved thread state for context switches.
In the Logo version there are at</font>
<br><font face="Comic Sans MS">most three stack frames; in the TT version
there are three thread frames</font>
<br><font face="Comic Sans MS">(c, d, e).</font>
<p><font face="Comic Sans MS">If the execution is truly parallel, then
of course that state won't wait around as long. But unless you're telling
me that a thread as *no* state information associated with it, I'm afraid
I still don't see where the saving of memory comes in.</font>
<p><font face="Comic Sans MS">Now, perhaps you are using a really bad memory
management system in which a large chunk of physical memory has to be located
for a stack, whether or not it's used. But that isn't the fault of stacks,
or Logo, or composition of functions!</font>
<p><font face="Comic Sans MS">And remember, nobody is arguing against concurrency
here. There's no reason why, if the tasks are independent, a Logo program
couldn't say</font>
<p><font face="Comic Sans MS">to a</font>
<br><font face="Comic Sans MS">spawn [b]</font>
<br><font face="Comic Sans MS">c</font>
<br><font face="Comic Sans MS">end</font>
<p><font face="Comic Sans MS">or whatever. What you are arguing is that
the ability to do procedure calls inevitably leads to storage loss, and
I still don't see it.</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Brian Harvey wrote in message &lt;<a href="mailto:73uosj$e1s$1@agate.berkeley.edu">73uosj$e1s$1@agate.berkeley.edu</a>>...</font>
<br><font face="Comic Sans MS">>If the execution is truly parallel, then
of course that state won't wait</font>
<br><font face="Comic Sans MS">>around as long. But unless you're telling
me that a thread has *no* state</font>
<br><font face="Comic Sans MS">>information associated with it, I'm afraid
I still don't see where the</font>
<br><font face="Comic Sans MS">>saving of memory comes in.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>Now, perhaps you are using a really bad
memory management system in which</font>
<br><font face="Comic Sans MS">>a large chunk of physical memory has to
be allocated for a stack, whether</font>
<br><font face="Comic Sans MS">>or not it's used. But that isn't the fault
of stacks, or Logo, or</font>
<br><font face="Comic Sans MS">>composition of functions!</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">Implementation arguments are slippery. You
seem to be arguing what is possible and I'm arguing what is current practice.
When Java died because I had a few hundred threads, I checked news groups
and talked to experts who said that is what you should expect. Now maybe
the Java implementors didn't do a very good job (and I tried it on more
than one Java implementation). But you really can have tens of thousands
of threads or processes in ToonTalk. Millions if there wasn't the overhead
of the ToonTalk programming environment (i.e. if ToonTalk supported invisible
houses that couldn't be entered).</font>
<p><font face="Comic Sans MS">I believe the Java implementation of threads
is good and that within their framework it would be too expensive to support
thousands of threads. I refer to Java only because I am more familiar with
it. I believe that the cost of threads is high in all mainstream languages
that have added threads.</font>
<p><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>or whatever. What you are arguing is that
the ability to do procedure</font>
<br><font face="Comic Sans MS">>calls inevitably leads to storage loss,
and I still don't see it.</font>
<p><font face="Comic Sans MS">"Inevitably" might be too strong a word.
I'm arguing it does in practice.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn (<a href="http://www.toontalk.com/">www.toontalk.com</a>)</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brian Harvey:</font>
<p><font face="Comic Sans MS">"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes:</font>
<br><font face="Comic Sans MS">>I believe the Java implementation of threads
is good and that within their</font>
<br><font face="Comic Sans MS">>framework it would be too expensive to
support thousands of threads. I refer</font>
<br><font face="Comic Sans MS">>to Java only because I am more familiar
with it. I believe that the cost of</font>
<br><font face="Comic Sans MS">>threads is high in all mainstream languages
that have added threads.</font>
<p><font face="Comic Sans MS">That may be. What I don't believe is that
the reason has to do with procedure stack frames; I can certainly get >
100,000 deep in procedure calls in Logo without trouble. (And of course
if it's a tail call, infinitely deep.)</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ray Catzel:</font>
<p><font face="Comic Sans MS">I have a headache. I have just spent an hour
(I thought Ken deserved it for all his hard work at promoting the product)
and ended by Uninstalling it from my system (Win98).</font>
<p><font face="Comic Sans MS">With all this talk about special features
of parallel processing and many others I really did not comprehend, I am
disappointed in the product. If this is intuitive for elementary school
kids,&nbsp; so is anything that you spend lots of time learning how it
works.</font>
<p><font face="Comic Sans MS">It is very visual. However, IMHO I don't
think kids will have an easier time working out how to operate a "vacuum
cleaner" (one of the numerous icons) than learning "copy and paste" concepts
in Windows.</font>
<p><font face="Comic Sans MS">I really don't want to waste any more time
on this evaluation description. If the others on the list want to evaluate
the product I can only reassure them that the software does uninstall.</font>
<p><font face="Comic Sans MS">I hate to submit a critique such as this
for a product that Ken has spent so much time on. But I'm only being honest.</font>
<p><font face="Comic Sans MS">Have Fun!</font>
<p><font face="Comic Sans MS">Ray Catzel,</font>
<br><font face="Comic Sans MS">President, ComputerPals Inc.</font>
<br><font face="Comic Sans MS">Web site: <a href="http://www.computerpals.on.ca/~pals">http://www.computerpals.on.ca/~pals</a></font>
<br><font face="Comic Sans MS">Email: learn@computerpals.on.ca</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">&nbsp;&nbsp; From Ken Kahn:</font>
<p><font face="Comic Sans MS">RAY CATZEL wrote</font>
<p><font face="Comic Sans MS">&nbsp;&nbsp;&nbsp; >I hate to submit a critique
such as this for a product that Ken has</font>
<br><font face="Comic Sans MS">spent so much time on. But I'm only being
honest.</font>
<p><font face="Comic Sans MS">&nbsp;&nbsp;&nbsp; I'm glad Ray downloaded
the trial version and spent an hour evaluating it. And I appreciate an
honest evaluation. My opinion is far from objective but</font>
<p><font face="Comic Sans MS">&nbsp;&nbsp;&nbsp; 1. I've collected a large
number of messages from beta testers (of all ages) who had praise for ToonTalk.
(<a href="http://www.toontalk.com/English/users.htm">www.toontalk.com/English/users.htm</a>).</font>
<p><font face="Comic Sans MS">&nbsp;&nbsp;&nbsp; 2. I've been working with
a 4th grade class since January 1995. I would say about 80% of the kids
get it and like it.</font>
<p><font face="Comic Sans MS">&nbsp;&nbsp;&nbsp; 3. One of my strongest
allies, Julian Pixton, was skeptical about ToonTalk until he watched kids
use it. He is the manager of the company that is now publishing ToonTalk
in Europe, Australia, Africa, and a few other places.</font>
<p><font face="Comic Sans MS">&nbsp;&nbsp;&nbsp; I have a theory about
why kids do fine with ToonTalk, while many adults don't. I borrowed nearly
all the user interface ideas from video and computer games. There are no
Windows/Mac widgets like menus, mouse cursors, buttons, etc. Adults expecting
a conventional interface find it confusing. Kids don't.</font>
<p><font face="Comic Sans MS">&nbsp;&nbsp;&nbsp; I urge people on this
list to try the trial version themselves (<a href="http://www.toontalk.com/English/free.htm">www.toontalk.com/English/free.htm</a>).
And, if at all possible, watch as a kid tries it.</font>
<p><font face="Comic Sans MS">&nbsp;&nbsp;&nbsp; Best,</font>
<p><font face="Comic Sans MS">&nbsp;&nbsp;&nbsp; -ken</font>
<br><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brett Leach:</font>
<p><font face="Comic Sans MS">RAY CATZEL wrote:</font>
<p><font face="Comic Sans MS">> I have a headache. ...</font>
<br>&nbsp;
<p><font face="Comic Sans MS">I have to disagree with this. I downloaded
ToonTalk a couple of nights ago. Woke up the next morning and found my
son (10) fascinated by TT. No instruction or anything, he just saw the
icon on my desktop and decided to check it out. I've watched him do some
incredible stuff so far.</font>
<br><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Wen "Wayne" Su:</font>
<p><font face="Comic Sans MS">ToonTalk, IMHO, is okay. The robot is a great
idea! However, I have one complaint about it and one suggestion. The problem
is that all the objects, such as boxes, and Pumpy, are too large. It often
gets annoying where you have to scroll around everywhere to find a particular
robot. The suggestion is that there should be a magnifying glass which
would allow you to observe what's in the box. When you drop multiple boxes
into another box, often some contents are so minuscule you can't read it
well. Although you can always pump it up, a magnifier would be more handy.
You can use the glass to see what's in it.</font>
<p><font face="Comic Sans MS">-an 11 year old</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Wen "Wayne" Su wrote in message &lt;<a href="mailto:73fm0u$kj6$1@news-1.news.gte.net">73fm0u$kj6$1@news-1.news.gte.net</a>>...</font>
<br><font face="Comic Sans MS">ToonTalk, IMHO, is okay. ...</font>
<p><font face="Comic Sans MS">Thanks for your post. And I like your magnifying
glass idea. With high resolution graphics it is easier to see small things.
(High resolution graphics requires a 30MB file only available on the CD-ROM.)
But a magnifying glass would help even then.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<br>&nbsp;
<p><font face="Comic Sans MS">From Doug Merrill:</font>
<p><font face="Comic Sans MS">This is my initial evaluation of Toontalk
and a comparison with Logo. I got to Toontalk and the Logo newsgroup by
typing "Computer Programming for Children" into an internet search engine.
I have an 8 year old son who spends "too much" time playing computer games.
I thought that I might get him interested in writing his own computer games.
I have MSWlogo installed and we are working on a quiz game. His idea is
to ask the user quiz questions. If the answer is wrong then the fuse on
a picture of a bomb will burn down. After a certain number of wrong answers
the bomb explodes. We have gotten a good start on making the bomb work.</font>
<p><font face="Comic Sans MS">Some things I really like about Logo are
that it is versatile. It looks like you can do anything with it - text,
pictures, movies, interaction. The papers at the Logo foundation web site
have lots of ideas and sample code, too.</font>
<p><font face="Comic Sans MS">When I first saw the demo version of Toontalk
I was very excited. My son loves computers and Legos. I enjoyed and was
challenged by the puzzle game. However, in the puzzle game and in free
play I ran into some iritating problems.</font>
<p><font face="Comic Sans MS">1. Placing the hand and other objects in
the right place is difficult. It is hard to press the button on Dusty.
It is difficult to find the right placement of a large text object to put
it in a box. Perhaps you (Ken Kahn) can put a red dot on each object to
indicate its "hot spot".</font>
<p><font face="Comic Sans MS">2. The floor gets cluttered fast. The window
gets filled quickly with notebooks, tools, robots and birds. To get rid
of a notebook I have to press F2 to get Dusty (this takes several seconds),
then put him down to check his button setting, pick him up to suck up the
notebook. Then I have to hope there is nothing important under the notebook
that gets sucked up by mistake. It would be nice to be able to point to
an object, press the delete key and have it disappear. Also when the robot
is done with the toolbox he does not put it back where he got it from (sound
like anybody in your house?). I spent some time looking for a bird only
to find that the robot had put the toolbox on top of it. A zoom feature
would be nice for looking for things. That is easier than panning across
the floor, and standing up does not allow you to see objects clearly. Perhaps
you could have a toolbar instead of the tool box. A toolbar is out of the
way and won't get covered up. The user could right click on the object
in the toolbar to get a new copy and left click on the object on the toolbar
to make all of those objects in the main screen float up to the top.</font>
<p><font face="Comic Sans MS">3. The puzzle game was excellent for teaching
me how to do things. It got very long, however. A couple times Marty said
"We're almost done", but we were not. I quit after the section on the clock
and started working on my own. But, how much did I miss? What are the upcoming
topics? Is it worth my time to go through them? I cannot find answers to
these questions. The puzzle game needs a table of contents and a way to
jump to a specific section I am interested in. This brings up the whole
concept of help. Traditional Windows help has a table of contents and an
index (just like a real book). Toontalk does not have this, Logo does.
When I am learning a new computer language I want a reference book where
I can look up the syntax of what I want to do and get examples that I can
cut-and-paste. But there is no cut-and-paste with Toontalk. I have not
seen the trading card manual (Is it one card for each character?), but
I cannot imagine that the cards would have enough information on them.
Would they correspond to a quick reference page?</font>
<p><font face="Comic Sans MS">4. This leads to a serious problem for Toontalk.
I cannot edit my program. Several times in the puzzle game I made mistakes
- I did things in the wrong order, handed the robot a box with the wrong
number of holes. But I had no way to go back and change it. This happened
in the Ping-Pong demo. The programmer made the paddle wrong. She/he had
to get rid of the bad paddle and create a new one from the beginning. A
big advantage of using a text based language is that I can edit and re-use
(cut-and-paste) code. An Undo command would be very helpful while I am
on the floor creating my program. Better yet - is there someway to edit
aminmation based programs? There were several times during the puzzle game
where the only way to get out of a mistake was to blow up the whole building
and start over. This seems extreme to me. I imagine children would get
very frustrated.</font>
<p><font face="Comic Sans MS">I showed Toontalk to my son. He looked at
some of the demos and then wanted to write his own program to make the
buildings blow up. He had not paid close attention to how it was done in
the demo, but he knew it involved a bomb and a truck. He put the bomb in
the truck - Marty came to say that was not possible, bomb needed to be
in a box. (This was very good - context specific help.) My son put the
bomb in a box and the box in the truck. The truck did not move. I told
my son that I thought the truck would only move if there was a robot in
it. Together we made a program that made continuously exploding buildings.
He liked going up in the helicopter and watching the buildings explode.
I asked him what he wanted to do next and he asked me if I thought we could
make an airport with airplanes taking off from it. I told him I did not
think so.</font>
<p><font face="Comic Sans MS">This is a problem. Toontalk looks like Legos,
so kids will want to do Lego-like things with it. I don't think Lego-like
things are possible - are they? A house is not just a house, it is a metaphor
for a computational process. The only way to build a house is to create
a process to happen inside it. And I have no choice in what the house looks
like. Also, all the action happens inside the houses. If I make a city
I want to be able to walk around and see things happening (like SimCity).
But all I will be able to see in Toontalk is trucks, birds and explosions
(let me know if I am wrong).</font>
<p><font face="Comic Sans MS">I am having a hard time imaging what I can
do with Toontalk that would interest me. The Ping-Pong game looks very
crude compared to the initial "wow" of the first encounter with Toontalk.
How would my son make his quiz game in Toontalk? I tried putting text on
the wall of the room - it was clumsy. But then again, Toontalk is an animated
programming language, maybe it doesn't do text well. What does it to well?
I am the kind of person who needs lots of examples.</font>
<p><font face="Comic Sans MS">On the other hand I was blown away by the
3D examples in MSWLogo. I want to make a sphere with land masses colored
on the surface and make a GIF movie of it (the earth) rotating. I wonder
how much computer time a movie of, say, 12 frames would take. Now I understand
better how computer animation is done and why Hollywood computer animation
requires lots of time and memory. Logo makes me imagine things and wonder
about things. I can imagine making a Logo airport with my son - make a
bitmap of an airport as the background, then turn the turtles into airplanes
and program them to fly. It would be 2-dimensional, not as pretty as Toontalk.
But is something like that even possible with Toontalk?</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Doug Merrill wrote</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>When I first saw the demo version of Toontalk
I was very excited. My</font>
<br><font face="Comic Sans MS">>son loves computers and Legos. I enjoyed
and was challenged by the</font>
<br><font face="Comic Sans MS">>puzzle game. However, in the puzzle game
and in free play I ran into</font>
<br><font face="Comic Sans MS">>some iritating problems.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>1. Placing the hand and other objects in
the right place is difficult.</font>
<br><font face="Comic Sans MS">>It is hard to press the button on Dusty.
It is difficult to find the</font>
<br><font face="Comic Sans MS">>right placement of a large text object
to put it in a box. Perhaps you</font>
<br><font face="Comic Sans MS">>(Ken Kahn) can put a red dot on each object
to indicate its "hot spot".</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">A red spot would work but ToonTalk, like
movies, novels, and many video games, relies upon a "suspension of disbelief".
So I am wary of adding anything that might interfere with the fantasy of
being in this animated world. Selection is indicated in ToonTalk by wiggling.
An object "trembles" because it senses it might be picked up, or vacuumed,
or whatever. The price of innovation is that users have to learn to notice
the wiggling - there are no wide-spread conventions to rely on.</font>
<p><font face="Comic Sans MS">>2. The floor gets cluttered fast. The window
gets filled quickly with</font>
<br><font face="Comic Sans MS">>notebooks, tools, robots and birds.</font>
<p><font face="Comic Sans MS">You are right, it does. This is because everything
is pretty large. You can use Pumpy to shrink things down (and with the
high resolution graphics you can shrink them quite a lot and still use
them effectively). ToonTalk will remember what size and position you like
for your tools. ToonTalk is meant to work with a wide range of users. Large
objects are appropriate for young kids and novices. Older and more experienced
users learn how to customize ToonTalk to their liking.</font>
<p><font face="Comic Sans MS">>To get rid of a notebook I have to</font>
<br><font face="Comic Sans MS">>press F2 to get Dusty (this takes several
seconds), then put him down to</font>
<br><font face="Comic Sans MS">>check his button setting, pick him up to
suck up the notebook. Then I</font>
<br><font face="Comic Sans MS">>have to hope there is nothing important
under the notebook that gets</font>
<br><font face="Comic Sans MS">>sucked up by mistake. It would be nice
to be able to point to an</font>
<br><font face="Comic Sans MS">>object, press the delete key and have it
disappear.</font>
<p><font face="Comic Sans MS">Again, I decided to try to maintain the underlying
fantasy. F2 makes a sound so Dusty comes running to you. F2 while Dusty
is coming means you are impatient and he gets there instantly. Pressing
the delete key might be a nice short cut for F2, F2, space (to turn him
on), space (to turn him off). Thanks for the suggestion.</font>
<p><font face="Comic Sans MS">>Also when the robot</font>
<br><font face="Comic Sans MS">>is done with the toolbox he does not put
it back where he got it from</font>
<br><font face="Comic Sans MS">>(sound like anybody in your house?). I
spent some time looking for a</font>
<br><font face="Comic Sans MS">>bird only to find that the robot had put
the toolbox on top of it. A</font>
<br><font face="Comic Sans MS">>zoom feature would be nice for looking
for things. That is easier than</font>
<br><font face="Comic Sans MS">>panning across the floor, and standing
up does not allow you to see</font>
<br><font face="Comic Sans MS">>objects clearly. Perhaps you could have
a toolbar instead of the tool</font>
<br><font face="Comic Sans MS">>box. A toolbar is out of the way and won't
get covered up. The user</font>
<br><font face="Comic Sans MS">>could right click on the object in the
toolbar to get a new copy and</font>
<br><font face="Comic Sans MS">>left click on the object on the toolbar
to make all of those objects in</font>
<br><font face="Comic Sans MS">>the main screen float up to the top.</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">I like the fantasy that the tool box is character
that follows you where you go. It also "explains" why things that "live"
in the tool box are the same no matter what room you go to. I'll look into
the problem of a robot being trained to move the tool box covering things
up - it shouldn't. Thanks for reporting it.</font>
<p><font face="Comic Sans MS">>3. The puzzle game was excellent for teaching
me how to do things. It</font>
<br><font face="Comic Sans MS">>got very long, however. A couple times
Marty said "We're almost done",</font>
<br><font face="Comic Sans MS">>but we were not. I quit after the section
on the clock and started</font>
<br><font face="Comic Sans MS">>working on my own. But, how much did I
miss? What are the upcoming</font>
<br><font face="Comic Sans MS">>topics? Is it worth my time to go through
them? I cannot find answers</font>
<br><font face="Comic Sans MS">>to these questions. The puzzle game needs
a table of contents and a way</font>
<br><font face="Comic Sans MS">>to jump to a specific section I am interested
in.</font>
<p><font face="Comic Sans MS">A very good suggestion. I'll make a guide
to the puzzle section. Thanks.</font>
<p><font face="Comic Sans MS">>This brings up the</font>
<br><font face="Comic Sans MS">>whole concept of help. Traditional Windows
help has a table of contents</font>
<br><font face="Comic Sans MS">>and an index (just like a real book).</font>
<p><font face="Comic Sans MS">There is <a href="http://www.toontalk.com/English/doc.htm">www.toontalk.com/English/doc.htm</a>.
You can reach a local copy on your hard disk from the Help button after
starting ToonTalk. And Marty can be called to explain anything you are
holding or pointing to by pressing F1.</font>
<p><font face="Comic Sans MS">>Toontalk does not have this, Logo</font>
<br><font face="Comic Sans MS">>does. When I am learning a new computer
language I want a reference</font>
<br><font face="Comic Sans MS">>book where I can look up the syntax of
what I want to do and get</font>
<br><font face="Comic Sans MS">>examples that I can cut-and-paste. But
there is no cut-and-paste with</font>
<br><font face="Comic Sans MS">>Toontalk.</font>
<p><font face="Comic Sans MS">There is cut and paste (see the sensor on
Page 30 of the sensor notebook). But as you point out below, there is this
issue of editing...</font>
<p><font face="Comic Sans MS">>I have not seen the trading card manual
(Is it one card for</font>
<br><font face="Comic Sans MS">>each character?), but I cannot imagine
that the cards would have enough</font>
<br><font face="Comic Sans MS">>information on them. Would they correspond
to a quick reference page?</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">Yes.</font>
<p><font face="Comic Sans MS">>4. This leads to a serious problem for Toontalk.
I cannot edit my</font>
<br><font face="Comic Sans MS">>program. Several times in the puzzle game
I made mistakes - I did</font>
<br><font face="Comic Sans MS">>things in the wrong order, handed the robot
a box with the wrong number</font>
<br><font face="Comic Sans MS">>of holes. But I had no way to go back and
change it. This happened in</font>
<br><font face="Comic Sans MS">>the Ping-Pong demo. The programmer made
the paddle wrong. She/he had</font>
<br><font face="Comic Sans MS">>to get rid of the bad paddle and create
a new one from the beginning. A</font>
<br><font face="Comic Sans MS">>big advantage of using a text based language
is that I can edit and</font>
<br><font face="Comic Sans MS">>re-use (cut-and-paste) code. An Undo command
would be very helpful</font>
<br><font face="Comic Sans MS">>while I am on the floor creating my program.
Better yet - is there</font>
<br><font face="Comic Sans MS">>someway to edit aminmation based programs?
There were several times</font>
<br><font face="Comic Sans MS">>during the puzzle game where the only way
to get out of a mistake was to</font>
<br><font face="Comic Sans MS">>blow up the whole building and start over.
This seems extreme to me. I</font>
<br><font face="Comic Sans MS">>imagine children would get very frustrated.</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">The design and engineering of an editor for
an animated language like ToonTalk is a big undertaking. I have plenty
of ideas. The only thing implemented is that you can retrain a robot. If
you vacuum out the contents of his thought bubble and give him a box, you'll
enter his imagination. And the robot will begin to redo what he was trained
to do. At any point you can interrupt him and take over. On the average
it cuts your work in half.</font>
<p><font face="Comic Sans MS">The funny thing is that I haven't seen kids
getting frustrated redoing robots. There are lots of times when kids voluntarily
redo something over and over again until they get it right. This is extremely
common when playing video games. Kids will try over and over again to beat
a "boss" in Super Mario Brothers, for example.</font>
<p><font face="Comic Sans MS">>I asked</font>
<br><font face="Comic Sans MS">>him what he wanted to do next and he asked
me if I thought we could make</font>
<br><font face="Comic Sans MS">>an airport with airplanes taking off from
it. I told him I did not</font>
<br><font face="Comic Sans MS">>think so.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>This is a problem. Toontalk looks like
Legos, so kids will want to do</font>
<br><font face="Comic Sans MS">>Lego-like things with it. I don't think
Lego-like things are possible -</font>
<br><font face="Comic Sans MS">>are they? A house is not just a house,
it is a metaphor for a</font>
<br><font face="Comic Sans MS">>computational process. The only way to
build a house is to create a</font>
<br><font face="Comic Sans MS">>process to happen inside it. And I have
no choice in what the house</font>
<br><font face="Comic Sans MS">>looks like. Also, all the action happens
inside the houses. If I make</font>
<br><font face="Comic Sans MS">>a city I want to be able to walk around
and see things happening (like</font>
<br><font face="Comic Sans MS">>SimCity). But all I will be able to see
in Toontalk is trucks, birds</font>
<br><font face="Comic Sans MS">>and explosions (let me know if I am wrong).</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">You can add objects to a city and they can
have robots on the back giving them a behavior. But the more general answer
is to use the same techniques in the Ping Pong example. You can make a
combination of pictures with robots on the back giving the pictures any
behavior you like. The pictures can be the clip art included in ToonTalk
or imported BMP files. You can of course make the picture fill the screen
and cover all the ToonTalk object below.</font>
<p><font face="Comic Sans MS">>I am having a hard time imaging what I can
do with Toontalk that would</font>
<br><font face="Comic Sans MS">>interest me. The Ping-Pong game looks very
crude compared to the</font>
<br><font face="Comic Sans MS">>initial "wow" of the first encounter with
Toontalk. How would my son</font>
<br><font face="Comic Sans MS">>make his quiz game in Toontalk? I tried
putting text on the wall of the</font>
<br><font face="Comic Sans MS">>room - it was clumsy. But then again, Toontalk
is an animated</font>
<br><font face="Comic Sans MS">>programming language, maybe it doesn't
do text well. What does it to</font>
<br><font face="Comic Sans MS">>well? I am the kind of person who needs
lots of examples.</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">Text-oriented programs are possible, but
I concede they are more awkward in ToonTalk. Text can act just like a picture
and be combined with other text on a background. Text input is character-by-character
(though a word or line based input robot team could be built and put in
a library). (The Examples notebook does contain a sentence generator.)</font>
<p><font face="Comic Sans MS">Thanks for taking the time to both try ToonTalk
and write a long evaluation. And thanks for your good suggestions.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Wen Su sent a message to the ToonTalk discussion
list (<a href="mailto:toontalk@lists.best.com">toontalk@lists.best.com</a>)
where he brought up questions about a sequential ToonTalk. Given the recent
discussion here I thought I should re-post his message and my reply. Wen
wrote:</font>
<p><font face="Comic Sans MS">>I think I understand that the concurrency
feature is at the</font>
<br><font face="Comic Sans MS">>the heart of ToonTalk. But, after reading
some postings in Logo</font>
<br><font face="Comic Sans MS">>user's group, I feel it is sometimes difficult,
if not impossible,</font>
<br><font face="Comic Sans MS">>for some people to like/accept the idea
that there are alternative</font>
<br><font face="Comic Sans MS">>programming models than the traditional
step-by-step sequetinal</font>
<br><font face="Comic Sans MS">>programming model, that may be useful under
SOME situations.</font>
<br><font face="Comic Sans MS">>When I first learned to program, I myself
did not learn</font>
<br><font face="Comic Sans MS">>such concepts that are typically taught
in Operating System courses.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>For example, if some people are only interested
in introducing very simple</font>
<br><font face="Comic Sans MS">>sequential programming concepts to their
children, can ToonTalk, with</font>
<br><font face="Comic Sans MS">>some minor change, or "coated" with a thin
layer of code (so that the</font>
<br><font face="Comic Sans MS">>concurrency feature, which is just TOO
MUCH for them to digest now, is</font>
<br><font face="Comic Sans MS">hidden</font>
<br><font face="Comic Sans MS">>temporarily until they are ready for this),
is still useful to these</font>
<br><font face="Comic Sans MS">people?</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>TT's animation feature is of great helps
to beginners even in the pure</font>
<br><font face="Comic Sans MS">>sequential programming context. In a sense,
this is "Acting Turtle" but</font>
<br><font face="Comic Sans MS">>in bird's view rather than the first person
view. For example, if</font>
<br><font face="Comic Sans MS">>the beginners just want to learn the program
sequencing, or</font>
<br><font face="Comic Sans MS">>the "if statement", or loops, we may give
them "preprogrammed" robots which</font>
<br><font face="Comic Sans MS">does</font>
<br><font face="Comic Sans MS">>nothing rather than give orders to other
robots (via message passing</font>
<br><font face="Comic Sans MS">mechanism, but some</font>
<br><font face="Comic Sans MS">>actions are made invisible if appropriate).</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>This "highly-simplified, no-brainer" TT
may be more like an example TT</font>
<br><font face="Comic Sans MS">program</font>
<br><font face="Comic Sans MS">>rather than the general-purpose programming
environment (more or less like</font>
<br><font face="Comic Sans MS">an emulator.)</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>Games often provides difficulty levels.
So should TT, I think.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>I do not know this is just my dream that
just run wild, or it is feasible</font>
<br><font face="Comic Sans MS">>or desirable to provide such an emulated
environment.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>--Regards</font>
<br><font face="Comic Sans MS">>Wen</font>
<p><font face="Comic Sans MS">Wen brings up some interesting questions.</font>
<p><font face="Comic Sans MS">One question is could there be a version
of ToonTalk that was sequential? One might think it would be a small change
- instead of training a robot to drop a box and team of robots into a truck,
you train him to give the box to the team. We would then have replaced
process spawning by procedure calls. (Well, not quite if you also want
to deal with return values from the procedure call. You could also get
rid of birds and nests and make a version of ToonTalk where a robot left
something behind when he stopped. What he left behind could be the return
value.)</font>
<p><font face="Comic Sans MS">Would this sequential ToonTalk be easier
to use or understand? Could it do as much as the current ToonTalk? First
consider what it would be like to watch a computation as robots get hold
of other robots and give them boxes to work on. It could get messy and
confusing but maybe one could work out a good way to showing what is happening
(something like a stack of waiting</font>
<br><font face="Comic Sans MS">robots). I doubt that it would be easier
to understand (unless you already had learned some sequential programming
language and expect all other languages to work in a similar way - and
most do). Then there is the problem of game or sprite programming. The
Ping Pong demo depends critically on the ball, paddle, and score keeper
running in parallel - how would such a thing be programmed in a sequential
ToonTalk? (Of course, it is possible to simulate parallelism within a sequential
ToonTalk but that is messy and confusing.)</font>
<p><font face="Comic Sans MS">I agree with Wen that it is difficult for
some people (adults) to like/accept non-sequential programming. And they
may prefer teaching kids sequential languages. But I believe kids who have
never programmed expect computations to be concurrent. The world around
them is concurrent - cars are driving, birds are flying, kids are playing
soccer, and so on. They can walk and talk at the same. And forces are concurrent
- they toss a ball on a windy day and both gravity and the wind act upon
it. What is natural about sequential procedure calls?</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn (<a href="http://www.toontalk.com/">www.toontalk.com</a>)</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brian Harvey:</font>
<p><font face="Comic Sans MS">"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes:</font>
<br><font face="Comic Sans MS">>I agree with Wen that it is difficult for
some people (adults) to</font>
<br><font face="Comic Sans MS">>like/accept non-sequential programming.
And they may prefer teaching kids</font>
<br><font face="Comic Sans MS">>sequential languages. But I believe kids
who have never programmed expect</font>
<br><font face="Comic Sans MS">>computations to be concurrent. The world
around them is concurrent - cars</font>
<br><font face="Comic Sans MS">>are driving, birds are flying, kids are
playing soccer, and so on. They can</font>
<br><font face="Comic Sans MS">>walk and talk at the same. And forces are
concurrent - they toss a ball on a</font>
<br><font face="Comic Sans MS">>windy day and both gravity and the wind
act upon it. What is natural about</font>
<br><font face="Comic Sans MS">>sequential procedure calls?</font>
<p><font face="Comic Sans MS">My question is, why does it have to be either/or?
StarLogo is about as parallel as a language can get, but it still allows
composition of functions where that's appropriate.</font>
<p><font face="Comic Sans MS">When kids play games, there are lots of sequential
things that happen. First you hit the ball, then you run around the bases.
I think this business about sequential VERSUS parallel is a red herring.
The question is why you feel the need to throw 3,000 years of mathematics
out the window just because you have a new idea -- can't you still remember
the old ideas? (Just in case it's not obvious, the 3,000 years are about
composition of functions.)</font>
<p><font face="Comic Sans MS">In fact, from my point of view, it's particularly
ironic that you use "sequential" as a dirty word, since TT is much *more*
sequential than any other programming language I've ever seen, even BASIC.
Where I can say</font>
<br><font face="Comic Sans MS">(2+3) * (4+5)</font>
<br><font face="Comic Sans MS">putting my focus on the answer I want, you
have to say</font>
<br><font face="Comic Sans MS">pick up a 2</font>
<br><font face="Comic Sans MS">put it in a box</font>
<br><font face="Comic Sans MS">pick up a 3</font>
<br><font face="Comic Sans MS">put it on top of the box</font>
<br><font face="Comic Sans MS">wait a few minutes while they get bammed
together</font>
<br><font face="Comic Sans MS">now put that down and pick up another box</font>
<br><font face="Comic Sans MS">pick up a 4</font>
<br><font face="Comic Sans MS">put it in a box</font>
<br><font face="Comic Sans MS">pick up a 5</font>
<br><font face="Comic Sans MS">put it on top of the box</font>
<br><font face="Comic Sans MS">wait a few more minutes</font>
<br><font face="Comic Sans MS">get the 9 out of the box</font>
<br><font face="Comic Sans MS">somehow (I haven't gotten that far yet)
put a times sign</font>
<br><font face="Comic Sans MS">in front of it</font>
<br><font face="Comic Sans MS">now pick up the 5 from the 2+3</font>
<br><font face="Comic Sans MS">put it on the X9</font>
<br><font face="Comic Sans MS">wait some more</font>
<br><font face="Comic Sans MS">You call that not sequential?</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Brian Harvey wrote in message &lt;<a href="mailto:73phsa$218$1@agate.berkeley.edu">73phsa$218$1@agate.berkeley.edu</a>>...</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>My question is, why does it have to be
either/or? StarLogo is about as</font>
<br><font face="Comic Sans MS">>parallel as a language can get, but it
still allows composition of</font>
<br><font face="Comic Sans MS">>functions where that's appropriate.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>When kids play games, there are lots of
sequential things that happen.</font>
<br><font face="Comic Sans MS">>First you hit the ball, then you run around
the bases. I think this</font>
<br><font face="Comic Sans MS">>business about sequential VERSUS parallel
is a red herring. The question</font>
<br><font face="Comic Sans MS">>is why you feel the need to throw 3,000
years of mathematics out the</font>
<br><font face="Comic Sans MS">>window just because you have a new idea
-- can't you still remember the</font>
<br><font face="Comic Sans MS">>old ideas? (Just in case it's not obvious,
the 3,000 years are about</font>
<br><font face="Comic Sans MS">>composition of functions.)</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">I happen to think functional composition
is a red herring. It is only a SYNTATIC issue. Consider computing the number
of seconds in a day. You can use functional composition and enter an expression
like</font>
<p><font face="Comic Sans MS">(* hours_in_a_day (* minutes_in_an_hour seconds_in_a_minute))</font>
<p><font face="Comic Sans MS">or you can avoid functional composition and
write</font>
<p><font face="Comic Sans MS">(let ((seconds_in_an_hour (* minutes_in_an_hour
seconds_in_a_minute))</font>
<br><font face="Comic Sans MS">(* hours_in_a_day seconds_in_an_hour)</font>
<br><font face="Comic Sans MS">)</font>
<p><font face="Comic Sans MS">I don't see this as a big issue. One could
even argue that the second way is a better programming style since you
name intermediate results. And logic and relations are at least as old
as functions. Functions are just a special case of relations that are many-to-one.</font>
<p><font face="Comic Sans MS">>In fact, from my point of view, it's particularly
ironic that you use</font>
<br><font face="Comic Sans MS">>"sequential" as a dirty word, since TT
is much *more* sequential than</font>
<br><font face="Comic Sans MS">>any other programming language I've ever
seen, even BASIC. Where I can</font>
<br><font face="Comic Sans MS">>say</font>
<br><font face="Comic Sans MS">> (2+3) * (4+5)</font>
<br><font face="Comic Sans MS">>putting my focus on the answer I want,
you have to say</font>
<br><font face="Comic Sans MS">> pick up a 2</font>
<br><font face="Comic Sans MS">> put it in a box</font>
<br><font face="Comic Sans MS">> pick up a 3</font>
<br><font face="Comic Sans MS">> put it on top of the box</font>
<br><font face="Comic Sans MS">> wait a few minutes while they get bammed
together</font>
<br><font face="Comic Sans MS">> now put that down and pick up another
box</font>
<br><font face="Comic Sans MS">> pick up a 4</font>
<br><font face="Comic Sans MS">> put it in a box</font>
<br><font face="Comic Sans MS">> pick up a 5</font>
<br><font face="Comic Sans MS">> put it on top of the box</font>
<br><font face="Comic Sans MS">> wait a few more minutes</font>
<br><font face="Comic Sans MS">> get the 9 out of the box</font>
<br><font face="Comic Sans MS">> somehow (I haven't gotten that far yet)
put a times sign</font>
<p><font face="Comic Sans MS">Type x, X, or * while holding the 9.</font>
<p><font face="Comic Sans MS">> in front of it</font>
<br><font face="Comic Sans MS">> now pick up the 5 from the 2+3</font>
<br><font face="Comic Sans MS">> put it on the X9</font>
<br><font face="Comic Sans MS">> wait some more</font>
<br><font face="Comic Sans MS">>You call that not sequential?</font>
<p><font face="Comic Sans MS">Yes, it is expressed sequentially. But this
style is only when using primitive operations like arithmetic. (And since
pure arithmetic is very easy to parallelize this could run in parallel
in principle.) A purist could train a robot to take a box with 2 numbers
and bird, combine the numbers appropriately and give the bird the result.
You can then program (2+3) * (4+5) by loading up trucks with this robot
so it does run in parallel. This is sometimes a better style. It is used
in the doubly recursive version of factorial (see <a href="http://www.toontalk.com/English/programs.htm">www.toontalk.com/English/programs.htm</a>).)</font>
<p><font face="Comic Sans MS">ToonTalk provides an "immediate mode" version
of arithmetic because I believe it is easier (and more fun since Bammer
the Mouse is popular with kids). But the computer scientist in me thinks
I shouldn't have made a special case of arithmetic when it wasn't strictly
necessary. Prolog, by the way, also provides a special syntax for arithmetic
that isn't strictly necessary.</font>
<p><font face="Comic Sans MS">It is true that you hit the ball before you
run around the bases. The design question here is whether you make a more
complex language and implementation and support both parallel and sequential
executions or not. I chose to keep things simple. So to program this you
need to have the part of the program that decides that a ball is hit to
give a bird a token indicating that the ball has been hit. The part of
the program for running around the bases has to be waiting for that token
to arrive before starting. It is not that hard to express things this way.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn (<a href="http://www.toontalk.com/">www.toontalk.com</a>)</font>
<br><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes:</font>
<br><font face="Comic Sans MS">>It is true that you hit the ball before
you run around the bases. The design</font>
<br><font face="Comic Sans MS">>question here is whether you make a more
complex language and implementation</font>
<br><font face="Comic Sans MS">>and support both parallel and sequential
executions or not. I chose to keep</font>
<br><font face="Comic Sans MS">>things simple.</font>
<p><font face="Comic Sans MS">I think this may be the core of our disagreement.
It's not quite clear from that sentence whether you mean "simple for the
implementor" or "simple for the user." If the former, we disagree in principle.
If the latter, we disagree about user interface strategy. I'm not convinced
that simplicity means "give the user a hammer and teach him that everything
is a nail"!</font>
<p><font face="Comic Sans MS">You started this whole discussion by saying
that computer science has moved on since Logo, and we should support new
paradigms. So I think it's worth noting that the mainstream languages that
support parallelism and OOP haven't thrown out other expressive mechanisms;
afaik that's unique to TT.</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Brian Harvey wrote in message &lt;<a href="mailto:73unos$dlc$1@agate.berkeley.edu">73unos$dlc$1@agate.berkeley.edu</a>>...</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>I think this may be the core of our disagreement.
It's not quite clear</font>
<br><font face="Comic Sans MS">from</font>
<br><font face="Comic Sans MS">>that sentence whether you mean "simple
for the implementor" or "simple for</font>
<br><font face="Comic Sans MS">>the user." If the former, we disagree in
principle. If the latter, we</font>
<br><font face="Comic Sans MS">>disagree about user interface strategy.
I'm not convinced that simplicity</font>
<br><font face="Comic Sans MS">>means "give the user a hammer and teach
him that everything is a nail"!</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">I do mean the user. Though I would like advanced
users to have a good idea of how things are implemented. Don't Scheme and
Lisp courses teach students how to write meta-interpreters? That is a lot
harder to do if the language isn't simple.</font>
<p><font face="Comic Sans MS">When I first came to Xerox PARC (1984) I
became heavily involved in a multi-paradigm language project (called Loops,
then InterLoops, then CommonLoops, and I dropped out when it became CLOS).
I recall reviewing a paper written at Bell Labs that argued persuasively
that there were very large cognitive and collaborative costs to using such
rich languages. I became convinced that it is hard for most people to switch
between different programming paradigms at the fine-grain that these languages
enable. And the author of the paper reported on the problems teams at Bell
Labs had due to different members using very different ways of programming.
Team members found it hard to understand and modify each other's code.</font>
<p><font face="Comic Sans MS">Also there can be interference between the
parts. A Prolog-like, logic programming, component has troubles integrating
well with an imperative sub-language. A pure functional component permits
all sorts of program transformations and parallel executions that break
when integrated with languages with side-effects.</font>
<p><font face="Comic Sans MS">>You started this whole discussion by saying
that computer science has moved</font>
<br><font face="Comic Sans MS">>on since Logo, and we should support new
paradigms. So I think it's worth</font>
<br><font face="Comic Sans MS">>noting that the mainstream languages that
support parallelism and OOP haven't</font>
<br><font face="Comic Sans MS">>thrown out other expressive mechanisms;
afaik that's unique to TT.</font>
<p><font face="Comic Sans MS">Yes, the mainstream has just added parallelism
to existing frameworks. And professional programmers have a hard time understanding
and debugging Java programs with threads (and Java is one of the better
examples of this). Computer scientists continue to explore actor, functional,
logic-based, and constraint-based programming languages that, like ToonTalk,
throw out some old ideas in order to make progress. In contrast, the computer
industry or mainstream just tries to graft new things on the old.</font>
<p><font face="Comic Sans MS">This news group is about Logo - about powerful
programming languages for kids. Unlike the mainstream, the constraints
of legacy systems and backwards compatibility are minimal. And we can give
kids the ability to make parallel programs without forcing them to master
the complexity of locks and atomic regions. And without expecting them
to debug race conditions and deadlocks.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn (<a href="http://www.toontalk.com/">www.toontalk.com</a>)</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brian Harvey:</font>
<p><font face="Comic Sans MS">"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes:</font>
<br><font face="Comic Sans MS">> I recall reviewing a</font>
<br><font face="Comic Sans MS">>paper written at Bell Labs that argued
persausively that there were very</font>
<br><font face="Comic Sans MS">>large cognitive and collaborative costs
to using such rich languages. I</font>
<br><font face="Comic Sans MS">>became convinced that it is hard for most
people to switch between different</font>
<br><font face="Comic Sans MS">>programming paradigms at the fine-grain
that these languages enable.</font>
<p><font face="Comic Sans MS">I guess I'd like to know whether all paradigms
are equally hard in this sense. My teaching experience has made me (reluctantly!)
conclude that sequential programming is most natural for most people, and
that functional programming takes more mental effort (although the effort
does pay off dramatically). Where is concurrent programming on that scale?
What is the marginal cost of keeping function composition in a language,
on that scale, versus the marginal cost of including concurrency?</font>
<p><font face="Comic Sans MS">>Also there can be interference between the
parts. A Prolog-like, logic</font>
<br><font face="Comic Sans MS">>programming, component has troubles integrating
well with an imperative</font>
<br><font face="Comic Sans MS">>sub-language. A pure functional component
permits all sorts of program</font>
<br><font face="Comic Sans MS">>transformations and parallel executions
that break when integrated with</font>
<br><font face="Comic Sans MS">>languages with side-effects.</font>
<p><font face="Comic Sans MS">I was with you on the logic programming example,
but the functional one seems to me to be a bit of sleight-of-hand; there
you are talking about complexity for the implementor, not cognitive load
for the user.</font>
<p><font face="Comic Sans MS">>Yes, the mainstream has just added parallelism
to existing frameworks. And</font>
<br><font face="Comic Sans MS">>professional programmers have a hard time
understanding and debugging Java</font>
<br><font face="Comic Sans MS">>programs with threads (and Java is one
of the better examples of this).</font>
<br><font face="Comic Sans MS">>Computer scientists continue to explore
actor, functional, logic-based, and</font>
<br><font face="Comic Sans MS">>constraint-based programming languages
that, like ToonTalk, throw out some</font>
<br><font face="Comic Sans MS">>old ideas in order to make progress. In
contrast, the computer industry or</font>
<br><font face="Comic Sans MS">>mainstream just tries to graft new things
on the old.</font>
<p><font face="Comic Sans MS">I'm convinced that it's difficult to debug
programs that combine concurrency with mutation of shared variables. I'm
not convinced, yet, that you can't have all of</font>
<br><font face="Comic Sans MS">* concurrency</font>
<br><font face="Comic Sans MS">* composition of functions without mutation</font>
<br><font face="Comic Sans MS">* mutation of local (not shared) variables</font>
<br><font face="Comic Sans MS">all in the same language, without trouble.</font>
<p><font face="Comic Sans MS">P.S. In Scheme we can do functional, sequential,
concurrent, and OOP, even though Scheme is, in at least one sense, a very
simple language. It doesn't have millions of primitives, like CLOS, or
a lot of syntax, like Java. We try to teach our students to be able to
use several programming paradigms, but to pay attention to which one they're
using. I suspect that those programmers you mention who had confusingly
mixed styles were handed a Common Lisp manual with no explicit instruction
about paradigms at all.</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Brian Harvey wrote in message &lt;<a href="mailto:73v2ml$lk6$1@agate.berkeley.edu">73v2ml$lk6$1@agate.berkeley.edu</a>>...</font>
<br><font face="Comic Sans MS">>I guess I'd like to know whether all paradigms
are equally hard in this</font>
<br><font face="Comic Sans MS">>sense. My teaching experience has made
me (reluctantly!) conclude that</font>
<br><font face="Comic Sans MS">>sequential programming is most natural
for most people, and that</font>
<br><font face="Comic Sans MS">>functional programming takes more mental
effort (although the effort</font>
<br><font face="Comic Sans MS">>does pay off dramatically). Where is concurrent
programming on that</font>
<br><font face="Comic Sans MS">>scale? What is the marginal cost of keeping
function composition in</font>
<br><font face="Comic Sans MS">>a language, on that scale, versus the marginal
cost of including</font>
<br><font face="Comic Sans MS">>concurrency?</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">Very good questions! Does anyone know of
research trying to answer these types of questions? Either in the computers
and education literature or the psychology of programming? (The only thing
I can think of is Mitch Resnick's masters thesis on MultiLogo.)</font>
<p><font face="Comic Sans MS">>>A pure functional component permits all
sorts of program</font>
<br><font face="Comic Sans MS">>>transformations and parallel executions
that break when integrated with</font>
<br><font face="Comic Sans MS">>>languages with side-effects.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>the functional one</font>
<br><font face="Comic Sans MS">>seems to me to be a bit of sleight-of-hand;
there you are talking about</font>
<br><font face="Comic Sans MS">>complexity for the implementor, not cognitive
load for the user.</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">How about concern for the order of execution
of the arguments to a function? In the pure case, you needn't bother yourself
about this. If there might be side-effects, you now have one more thing
to keep in mind.</font>
<p><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>I'm convinced that it's difficult to debug
programs that combine</font>
<br><font face="Comic Sans MS">>concurrency with mutation of shared variables.
I'm not convinced, yet,</font>
<br><font face="Comic Sans MS">>that you can't have all of</font>
<br><font face="Comic Sans MS">> * concurrency</font>
<br><font face="Comic Sans MS">> * composition of functions without mutation</font>
<br><font face="Comic Sans MS">> * mutation of local (not shared) variables</font>
<br><font face="Comic Sans MS">>all in the same language, without trouble.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">I'm not sure either. We'll just have to
wait for someone to build it (or at least design it in detail). But you'll
agree that there is no dialect of Logo that satisfies those criteria, right?</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn (<a href="http://www.toontalk.com/">www.toontalk.com</a>)</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brian Harvey:</font>
<p><font face="Comic Sans MS">"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes:</font>
<br><font face="Comic Sans MS">> But you'll agree that there is no dialect
of</font>
<br><font face="Comic Sans MS">>Logo that satisfies those criteria, right?</font>
<p><font face="Comic Sans MS">Yes, I agree with that. (Although we really
should look back at TLC Logo and RM Logo to see how they handled concurrency
issues.)</font>
<p><font face="Comic Sans MS">What's making me so curmudeonly about TT
is that with new software these days I always seem to have to give up three
things to get one new thing, and, while I've learned to expect this from
the likes of Microsoft, I don't want to have to put up with it from my
friends! :-)</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Brian Harvey wrote in message &lt;<a href="mailto:740836$i2l$1@agate.berkeley.edu">740836$i2l$1@agate.berkeley.edu</a>>...</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>What's making me so curmudeonly about TT
is that with new software</font>
<br><font face="Comic Sans MS">>these days I always seem to have to give
up three things to get one</font>
<br><font face="Comic Sans MS">>new thing, and, while I've learned to expect
this from the likes of</font>
<br><font face="Comic Sans MS">>Microsoft, I don't want to have to put
up with it from my friends! :-)</font>
<p><font face="Comic Sans MS">I see the arithmetic a bit differently:</font>
<p><font face="Comic Sans MS">Logo - synchronous procedure calls - global
variables - sequential execution - functional composition + concurrent
execution + asynchronous procedure calls + animated programming environment
+ demonstrative programming + objects + many-to-many communication channels
= (approximately) ToonTalk</font>
<p><font face="Comic Sans MS">Most of our discussion has been me been arguing
why the things I've added are good and why I felt the need to remove the
things I did. And you have been arguing I shouldn't have removed those
things.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn (<a href="http://www.toontalk.com/">www.toontalk.com</a>)</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Wen "Wayne" Su:</font>
<p><font face="Comic Sans MS">Ken Kahn wrote in message</font>
<br><font face="Comic Sans MS">>I see the arithmetic a bit differently:</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>Logo - synchronous procedure calls - global
variables - sequential</font>
<br><font face="Comic Sans MS">>execution - functional composition + concurrent
execution + asynchronous</font>
<br><font face="Comic Sans MS">>procedure calls + animated programming
environment + demonstrative</font>
<br><font face="Comic Sans MS">>programming + objects + many-to-many communication
channels =</font>
<br><font face="Comic Sans MS">>(approximately) ToonTalk</font>
<br>&nbsp;
<p><font face="Comic Sans MS">Although I may not know all these concepts
well, I enjoy reading discussions among members in this news group. Although
I have no clear ideas about what combinations of language features are
good for elementary/middle schoolers, there is definitely something new
or interesting to me in TT that makes me think.</font>
<p><font face="Comic Sans MS">Today, I find out that it seems there is
no explicit variable identifier in TT as we have in typical, text based
computer languages, in which we use a character string to identify a variable
at programming or coding time. What seems to be a variable in TT is not
explicitly given a name; it is just the "thing" you see on the screen,
which you can put a thing into it.</font>
<p><font face="Comic Sans MS">If this is true, does this mean you can teach
kids who do not know how to spell words yet to understand the concept of
variable? I guess not. I think for kids who are too young to learn to spell,
some features in TT should be temporarily disabled but some features are
still age-appropriate.</font>
<p><font face="Comic Sans MS">About the concurrency issue, it is important
in SOME context, and those kids who may become computer engineers definitely
need to learn these techniques/concepts sooner or later (But I do not know
how soon.) All hardware description languages used to design microprocessors
are concurrent in nature. A major architecture difference between an Intel
486 microprocessor and a Pentium microprocessor is the latter executes
instructions more concurrently. There are more concurrency issues that
need to be addressed for the next generation CPU (More concurrency logic
is going to be in the software compiler rather than the chips, though.)
The question is whether or not most of us still keep programming in sequential
languages, and let a selected few build the concurrent system for us. But
there is a need to let at least some children learn these concepts.</font>
<p><font face="Comic Sans MS">>Most of our discussion has been me been
arguing why the things I've added</font>
<br><font face="Comic Sans MS">>are good and why I felt the need to remove
the things I did. And you have</font>
<br><font face="Comic Sans MS">>been arguing I shouldn't have removed those
things.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>Best,</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>-ken kahn (<a href="http://www.toontalk.com/">www.toontalk.com</a>)</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">></font>
<br><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brian Harvey:</font>
<p><font face="Comic Sans MS">"Wen \"Wayne\" Su" &lt;<a href="mailto:Wen.Su@gte.net">Wen.Su@gte.net</a>>
writes:</font>
<br><font face="Comic Sans MS">>The question is whether or not most of
us still keep programming in</font>
<br><font face="Comic Sans MS">>sequential languages, and let a selected
few build the concurrent system</font>
<br><font face="Comic Sans MS">>for us. But there is a need to let at least
some children learn these</font>
<br><font face="Comic Sans MS">>concepts.</font>
<p><font face="Comic Sans MS">I don't think the design of Logo, or TT,
should or does revolve around the future needs of the computer industry!&nbsp;
My own CS-in-Logo books are an anomaly; the features we put in languages
for kids are chosen to support their general intellectual development,
we hope, and more specifically to turn them into mathematicians (by which
I mean formal thinkers).</font>
<p><font face="Comic Sans MS">The ones who will end up programming will
learn what they need to learn somewhere along the line.</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Wen Su:</font>
<p><font face="Comic Sans MS">Brian Harvey wrote in message &lt;<a href="mailto:744o1t$ofl$1@agate.berkeley.edu">744o1t$ofl$1@agate.berkeley.edu</a>>...</font>
<br><font face="Comic Sans MS">>"Wen \"Wayne\" Su" &lt;<a href="mailto:Wen.Su@gte.net">Wen.Su@gte.net</a>>
writes:</font>
<br><font face="Comic Sans MS">>>The question is whether or not most of
us still keep programming in</font>
<br><font face="Comic Sans MS">>>sequential languages,</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>I don't think the design of Logo, or TT,
should or does revolve around</font>
<br><font face="Comic Sans MS">>the future needs of the computer industry!&nbsp;
My own CS-in-Logo books are</font>
<br><font face="Comic Sans MS">>an anomaly; the features we put in languages
for kids are chosen to</font>
<br><font face="Comic Sans MS">>support their general intellectual development,
we hope, and more</font>
<br><font face="Comic Sans MS">>specifically to turn them into mathematicians
(by which I mean formal</font>
<br><font face="Comic Sans MS">>thinkers).</font>
<p><font face="Comic Sans MS">Well said.</font>
<p><font face="Comic Sans MS">I heard in most college adimissions process,
a computer science course is considered as a "solid" course, but a programming
course is not considered as solid as a computer science course. Is this
true? There must be some reasons.</font>
<p><font face="Comic Sans MS">When I first learned to program (in FORTRAN
IV), I thought programming was not very fun. Later, when I was learning
data structures (from the book "The Art of Computer Programming" by Knuth,
This was probably the only data structure book available at that time,
I think.), I started to understand that there is really something interesting
in this field --even though a pure education computer language called MIX
is used in that book to describe algorithms in details.</font>
<p><font face="Comic Sans MS">Maybe students today do not learn these things
from such an old book, especially if they learn that its author once wrote
an article: "Goto statements considered not harmful" or something like
that. (Just joking here.)</font>
<p><font face="Comic Sans MS">Having left schools for such a long time
makes me forget what should be learned in school. At least I would not
try to introduce C/C++ or BASIC to my kid who is still in the elementary
school; so I still have some common sense, I think.</font>
<p><font face="Comic Sans MS">Thanks for reminding me what kind of learning
is important in education.</font>
<p><font face="Comic Sans MS">--Wen Su</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Wen "Wayne" Su wrote in message &lt;<a href="mailto:742fo9$2vi$1@news-2.news.gte.net">742fo9$2vi$1@news-2.news.gte.net</a>>...</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">>Today, I find out that it seems there is
no explicit variable identifier in</font>
<br><font face="Comic Sans MS">>TT as we have in typical, text based computer
languages, in which we use</font>
<br><font face="Comic Sans MS">>a character string to identify a variable
at programming or coding time.</font>
<br><font face="Comic Sans MS">>What seems to be a variable in TT is not
explicitly given a name;</font>
<br><font face="Comic Sans MS">>it is just the "thing" you see on the screen,
which you can put a thing into</font>
<br><font face="Comic Sans MS">>it.</font>
<br><font face="Comic Sans MS">>If this is true, does this mean you can
teach kids who do not know how</font>
<br><font face="Comic Sans MS">>to spell words yet to understand the concept
of variable? I guess not.</font>
<br><font face="Comic Sans MS">>I think for kids who are too young to learn
to spell, some features in TT</font>
<br><font face="Comic Sans MS">>should be temporarily disabled but some
features are still age-appropriate.</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">The few times that I've watched 4 or 5 year
olds use ToonTalk, I didn't see that they had any problem with the concept
of variables in ToonTalk. They understand the concept that a box can have
several holes or compartments. They know that if hole #1 is empty and they
put something in it (let's call it A) and put something else in hole #2
(let's call it B) then if they come back to that box and take something
out of hole #2 they'll get B. They understand they can then fill the hole
with a new thing (C) and it'll be there if they come back. Holes in boxes
really are equivalent to variables. Just because they might not understand
the abstraction of variables, they</font>
<br><font face="Comic Sans MS">can program just fine by putting things
into and taking them out of holes in a box. So why disable this for young
children?</font>
<p><font face="Comic Sans MS">>The question is whether or not most of us
still keep programming in</font>
<br><font face="Comic Sans MS">>sequential languages, and let a selected
few build the concurrent system</font>
<br><font face="Comic Sans MS">>for us. But there is a need to let at least
some children learn these</font>
<br><font face="Comic Sans MS">>concepts.</font>
<br><font face="Comic Sans MS">></font>
<p><font face="Comic Sans MS">I agree with Brian Harvey that the primary
motivation here isn't job training. ToonTalk is concurrent because I think
concurrency is a better way to think about programming. Consider the ToonTalk
Ping Pong game example. In ToonTalk, the ball is programmed to bounce,
make sounds, and communicate with the score keeper. The paddle is programmed
to follow vertical movements of the mouse. The score keeper waits for messages
indicating a change and updates itself accordingly. I think, and I think
nearly everyone who is a</font>
<br><font face="Comic Sans MS">non-programmer thinks, that it is completely
natural and expected that these 3 processes are happening concurrently.
(Maybe even that the 3 behaviors of the ball are 3 processes.) Contrast
this with how in a sequential program one thinks about this. One has a
top-level loop which reads mouse movements, then updates the paddle position,
then it computes a new position for the ball, checks if it is colliding
and if so computes a new velocity, it then checks if the ball has missed
the paddle and if so updates the score. And</font>
<br><font face="Comic Sans MS">then it redisplays the paddle, ball, and
score before repeating the top level loop. I believe this is natural only
to programmers who have become used to dealing with a single thread of
execution.</font>
<p><font face="Comic Sans MS">In Mitch Resnick's masters thesis, he relates
a story of a girl he was trying to teach MultiLogo. The girl had mastered
sequential Logo the year before. She kept ignoring MultiLogo's concurrency
primitives and kept programming in a sequential manner. Mitch then asked
her how she and her brother would prepare dinner for the family. She said
she would stir the pot once, tell her brother to put down a fork, then
she would stir it again, and tell him to put down a spoon. Then she realized
how absurd this was and began to understand what Mitch was saying about
concurrent programming. [Disclaimer: I read his masters thesis several
years ago - and may not be remembering this story accurately.]</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken</font>
<br>&nbsp;
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">Brian Harvey:</font>
<p><font face="Comic Sans MS">"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes:</font>
<br><font face="Comic Sans MS">> Contrast this with how in a sequential
program</font>
<br><font face="Comic Sans MS">>one thinks about this. One has a top-level
loop which reads mouse movements,</font>
<br><font face="Comic Sans MS">>then updates the paddle position, then
it computes a new position for the</font>
<br><font face="Comic Sans MS">>ball, checks if it is colliding and if
so computes a new velocity, it then</font>
<br><font face="Comic Sans MS">>checks if the ball has missed the paddle
and if so updates the score. And</font>
<br><font face="Comic Sans MS">>then it redisplays the paddle, ball, and
score before repeating the top</font>
<br><font face="Comic Sans MS">>level loop.</font>
<p><font face="Comic Sans MS">I don't think this is quite fair.&nbsp; You
are assuming that the sequential language has lower-level graphics primitives
than the concurrent one, I think.&nbsp; Remember Atari Logo?&nbsp; It was
sort of "semi-concurrent"; you programmed it sequentially, but could set
up daemons to detect collisions and joystick movement asynchronously.&nbsp;&nbsp;
And turtles could have speeds. The part about first checking the ball position
and then updating the score is true, though.&nbsp; So, once again, my question
is not "is there any virtue to concurrency?" (clearly yes) but rather "do
we have to give up procedure calling and make everything fit into the Procrustean
(sp?) bed of threads?"&nbsp; Maybe there is a more incremental change possible.</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Brian Harvey wrote in message &lt;<a href="mailto:74ceon$4fn$1@agate.berkeley.edu">74ceon$4fn$1@agate.berkeley.edu</a>>...</font>
<p><font face="Comic Sans MS">>Remember Atari Logo?&nbsp; It was sort of
"semi-concurrent"; you</font>
<br><font face="Comic Sans MS">>programmed it sequentially, but could set
up daemons to detect collisions</font>
<br><font face="Comic Sans MS">>and joystick movement asynchronously.&nbsp;
And turtles could have speeds.</font>
<br><font face="Comic Sans MS">>The part about first checking the ball
position and then updating the</font>
<br><font face="Comic Sans MS">>score is true, though.&nbsp; So, once again,
my question is not "is there any</font>
<br><font face="Comic Sans MS">>virtue to concurrency?" (clearly yes) but
rather "do we have to give up</font>
<br><font face="Comic Sans MS">>procedure calling and make everything fit
into the Procrustean (sp?) bed</font>
<br><font face="Comic Sans MS">>of threads?"&nbsp; Maybe there is a more
incremental change possible.</font>
<p><font face="Comic Sans MS">I do remember Atari Logo and was excited
about it at the time.</font>
<p><font face="Comic Sans MS">I think the core of our friendly disagreement
is that I want a kind of uniformity. The approach of Atari Logo was to
provide support for some common special cases. But it didn't give you support
for others. Nor did it provide a smooth transition from built-in concurrency
to the user defined. A demon can wait for a collision and then run some
procedure. But can a demon wait for some user defined condition? I don't
think so. I favor a uniformly concurrent model of computation because it
subsumes sequential procedure</font>
<br><font face="Comic Sans MS">calls. I don't give up on them, I just don't
provide any support. But a ToonTalk user can express a sequential synchronous
procedure call - by training a robot to load up a truck with robots and
box with a bird and then arranging for the team of robots to wait until
the one of the robots that was put in the truck gives the bird the "return
value". Admittedly, it is more awkward than in other kinds of languages.</font>
<p><font face="Comic Sans MS">As a language designer, one is often faced
with the question of whether to give primitive, low-level support for common
special cases of what a more general mechanism can do. Doing so will make
some programs easier to express, but is likely to add complexity (for the
learner, user, and implementer). I believe a novice will find it easier
to deal with computations that are concurrent than computations which have
both concurrent and sequential parts.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn (<a href="http://www.toontalk.com">www.toontalk.com</a>)</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From <a href="mailto:luvisi@andru.sonoma.edu">luvisi@andru.sonoma.edu</a>:</font>
<br>&nbsp;
<p><font face="Comic Sans MS">disclaimer: I haven't seen Toon Talk.&nbsp;
I don't use Windows.</font>
<p><font face="Comic Sans MS">conjecture: Toon Talk is not capable of serving
as a development</font>
<br><font face="Comic Sans MS">environment for all applications one will
ever wish to create.&nbsp; that</font>
<br><font face="Comic Sans MS">is, anyone who keeps programming long enough,
and keeps making more</font>
<br><font face="Comic Sans MS">and more complex and/or functional programs
will, eventually,</font>
<br><font face="Comic Sans MS">"outgrow" Toon Talk.</font>
<p><font face="Comic Sans MS">this is based entirely on my observation
of the conversation in this</font>
<br><font face="Comic Sans MS">newsgroup so far, and a few visits to the
Toon Talk web site.</font>
<p><font face="Comic Sans MS">if this conjecture is correct, I would be
curious as to when/how you</font>
<br><font face="Comic Sans MS">(Ken Kahn) would expect a child who kept
"doing more" to "outgrow"</font>
<br><font face="Comic Sans MS">Toon Talk.&nbsp; I would also be curious
as to where you would recomend</font>
<br><font face="Comic Sans MS">they go when this happened.&nbsp; perhaps
another way of putting this is:</font>
<br><font face="Comic Sans MS">you clearly view Toon Talk as a "first step"
in a progression... what</font>
<br><font face="Comic Sans MS">else do you see in that progression?</font>
<p><font face="Comic Sans MS">if this conjecture is incorrect, I would
very much like to know your</font>
<br><font face="Comic Sans MS">reasoning as to why/how.</font>
<p><font face="Comic Sans MS">part of the reason I'm asking this is the
same reason I started</font>
<br><font face="Comic Sans MS">following this newsgroup a couple weeks
ago.&nbsp; I'm trying to understand</font>
<br><font face="Comic Sans MS">this amorpheous concept of "easy" as applied
to computer use and</font>
<br><font face="Comic Sans MS">programming.&nbsp; also, can you name any
other environments which share</font>
<br><font face="Comic Sans MS">what you believe to be Toon Talk's most
essential features?</font>
<p><font face="Comic Sans MS">* warning, the part below is a long description
of my personal search for</font>
<br><font face="Comic Sans MS">* enlightenment.&nbsp; it's longer than
I intended, and is mostly</font>
<br><font face="Comic Sans MS">* questions...</font>
<br><font face="Comic Sans MS">* it's also directed at anyone who'll listen,
rather than just Ken Kahn</font>
<p><font face="Comic Sans MS">I've dealt with many clients who are trying
to learn perl so they can</font>
<br><font face="Comic Sans MS">write CGIs, and I came to the conclusion
early on that perl, while</font>
<br><font face="Comic Sans MS">terribly convenient for many applications,
is a lousy first language</font>
<br><font face="Comic Sans MS">(even for adults).&nbsp; well, these people
would, naturally, be happy</font>
<br><font face="Comic Sans MS">writing in any other language... preferably
the "easiest" one for</font>
<br><font face="Comic Sans MS">them...&nbsp; so I started trying to come
up with something I could recomend</font>
<br><font face="Comic Sans MS">as an alternative to perl...</font>
<p><font face="Comic Sans MS">when I asked many months ago on comp.lang.perl.misc
"is perl a good</font>
<br><font face="Comic Sans MS">first language?", I got responses which
mostly echoed my own thoughts.</font>
<br><font face="Comic Sans MS">namely: it is not a good first language,
and the main reason was</font>
<br><font face="Comic Sans MS">because it is incredibly inconsistent.&nbsp;
someone learns a "rule", and</font>
<br><font face="Comic Sans MS">then they keep getting nailed by exceptions
to that rule, until they</font>
<br><font face="Comic Sans MS">have more or less memorized all of the exceptions.&nbsp;
much like english</font>
<br><font face="Comic Sans MS">spelling.</font>
<p><font face="Comic Sans MS">...so I figured out that consistency is an
important part of something</font>
<br><font face="Comic Sans MS">being "easy", but I know there's other things.</font>
<p><font face="Comic Sans MS">I like awk myself, and use it for many things,
since it has a high</font>
<br><font face="Comic Sans MS">degree of consistency, but beginners seem
to have trouble wrapping</font>
<br><font face="Comic Sans MS">their minds around the whole "implicit loop"
thing (for perl users,</font>
<br><font face="Comic Sans MS">awk always has the behavior perl has with
the -n option).&nbsp; awk was</font>
<br><font face="Comic Sans MS">designed to allow an advanced user to do
a medium level custom</font>
<br><font face="Comic Sans MS">filtering job on a file with one line of
code.&nbsp; other things came as</font>
<br><font face="Comic Sans MS">conveniences, and the authors admit it wasn't
designed to be a "first</font>
<br><font face="Comic Sans MS">language" (though they don't offer any thoughts
on what would be better).</font>
<br><font face="Comic Sans MS">there's a lesson here, but I don't know
what it is...&nbsp; don't start</font>
<br><font face="Comic Sans MS">with a specialized language?</font>
<p><font face="Comic Sans MS">BASIC (is that a bad word here?), as I learned
it on the apple II, is</font>
<br><font face="Comic Sans MS">a very consistent language.&nbsp; it is
also "easy" to grasp at first, but</font>
<br><font face="Comic Sans MS">once a programmer starts trying to do anything
requiring more than a</font>
<br><font face="Comic Sans MS">couple thought processes to execute, he
finds himself in spaghetti</font>
<br><font face="Comic Sans MS">code.&nbsp; then he finds gosub/return,
which takes care of him up to maybe</font>
<br><font face="Comic Sans MS">one or two hundred lines or so, but then
he starts having problems</font>
<br><font face="Comic Sans MS">with all variables being global(!).&nbsp;
and by then, he can have habits</font>
<br><font face="Comic Sans MS">which are hard to break when he finds a
language with dynamic scoping</font>
<br><font face="Comic Sans MS">(oh cool!) or lexical scoping (wow!), or
a while loop.&nbsp; I *hated*</font>
<br><font face="Comic Sans MS">having to use whiles instead of gotos when
I first was learning C.&nbsp; I</font>
<br><font face="Comic Sans MS">had learned to use gotos in DCL rather than
BASIC, but I can empathize</font>
<br><font face="Comic Sans MS">with the BASIC programmer unlearning the
same bad habbit.&nbsp; I think the</font>
<br><font face="Comic Sans MS">lesson here is that while gotos are easy,
they should be left out of</font>
<br><font face="Comic Sans MS">(or at least not encouraged) in a first
language.</font>
<p><font face="Comic Sans MS">C++, like perl, has all sorts of "magic"
in it... the same expression</font>
<br><font face="Comic Sans MS">can mean all sorts of things depending on
the context...</font>
<p><font face="Comic Sans MS">I think C is a better first language than
C++ because it has so much</font>
<br><font face="Comic Sans MS">less "magic", but string handling is such
a pain to do right in C,</font>
<br><font face="Comic Sans MS">and so dangerous to do wrong... it seems
wrong to me to teach budding</font>
<br><font face="Comic Sans MS">programmers dangerous practices like:</font>
<p><font face="Comic Sans MS">main()</font>
<br><font face="Comic Sans MS">{</font>
<br><font face="Comic Sans MS">char name[100];</font>
<p><font face="Comic Sans MS">printf("What is your name? ");</font>
<br><font face="Comic Sans MS">scanf("%s", name);</font>
<br><font face="Comic Sans MS">printf("Hello %s!\n", name);</font>
<br><font face="Comic Sans MS">}</font>
<p><font face="Comic Sans MS">but the alternative is to make them do it
the correct way.&nbsp; and to</font>
<br><font face="Comic Sans MS">write a safe version of the above, I can't
think of anything simpler than:</font>
<p><font face="Comic Sans MS">main()</font>
<br><font face="Comic Sans MS">{</font>
<br><font face="Comic Sans MS">char name[100];</font>
<br><font face="Comic Sans MS">int i;</font>
<p><font face="Comic Sans MS">printf("What is your name? ");</font>
<br><font face="Comic Sans MS">fgets(name, 100, stdin);</font>
<br><font face="Comic Sans MS">name[99] = '\0';</font>
<p><font face="Comic Sans MS">for(i=0; i &lt; 100; ++i)</font>
<br><font face="Comic Sans MS">&nbsp; if(name[i] == ' ' || name[i] == '\t'
|| name[i] == '\n')</font>
<br><font face="Comic Sans MS">&nbsp; {</font>
<br><font face="Comic Sans MS">&nbsp;&nbsp; name[i] = '\0';</font>
<br><font face="Comic Sans MS">&nbsp;&nbsp; break;</font>
<br><font face="Comic Sans MS">&nbsp; }</font>
<p><font face="Comic Sans MS">printf("Hello %s!\n", name);</font>
<p><font face="Comic Sans MS">but this isn't a suitable "second" program,
the way the above is... it</font>
<br><font face="Comic Sans MS">doesn't have just input and output.&nbsp;
it also has conditionals, loops,</font>
<br><font face="Comic Sans MS">character constants, strings-as-null-terminated-arrays-of-chars,
etc.</font>
<p><font face="Comic Sans MS">while in my search for understanding with
respect to what makes a good</font>
<br><font face="Comic Sans MS">first language, and what makes something
"easy", I saw a manual for</font>
<br><font face="Comic Sans MS">AppleLogoII at the local friends of the
library book sale.&nbsp; I happen</font>
<br><font face="Comic Sans MS">to own several Apple IIs (love the things,
and they serve as a</font>
<br><font face="Comic Sans MS">constant reminder to me of why I use Linux.&nbsp;
no one company or person</font>
<br><font face="Comic Sans MS">can kill Linux the way Apple killed the
Apple II.&nbsp; but I digress.)</font>
<br><font face="Comic Sans MS">thinking "hay, logo's for kids.&nbsp; it
must be easy.&nbsp; maybe it would make</font>
<br><font face="Comic Sans MS">a good case study.", I bought it, picked
myself up a copy of</font>
<br><font face="Comic Sans MS">AppleLogoII, and started learning it.&nbsp;
frankly, it just reminded me of</font>
<br><font face="Comic Sans MS">elisp (the only lisp dialect I am very familiar
with, though I know a</font>
<br><font face="Comic Sans MS">*teeny* bit of scheme) with some different
names, and '(...) replaced</font>
<br><font face="Comic Sans MS">with [...] and '... replaced with "... .</font>
<p><font face="Comic Sans MS">all the same concepts... recursion, variables,
itteration via tail</font>
<br><font face="Comic Sans MS">recursion, minus things like non-argument
local variables.</font>
<p><font face="Comic Sans MS">now, I've played with ucblogo, and I've seen
many of the improvements</font>
<br><font face="Comic Sans MS">and enhancements in it, but I still don't
get what I came trying to</font>
<br><font face="Comic Sans MS">understand...</font>
<p><font face="Comic Sans MS">-> what is it about logo (or any other language)
that is supposed to make</font>
<br><font face="Comic Sans MS">-> it "easy", and good as a first language?</font>
<p><font face="Comic Sans MS">-> how is it that logo (or any other language)
allows people to "easily"</font>
<br><font face="Comic Sans MS">-> express to the computer their thought
process?</font>
<p><font face="Comic Sans MS">I think I (more of less) understand how Toon
Talk acomplishes these,</font>
<br><font face="Comic Sans MS">based on Ken Kahn's multitude of kind explanations,
but I'm curious</font>
<br><font face="Comic Sans MS">about how he or anyone else would suggest
someone move from the Toon</font>
<br><font face="Comic Sans MS">Talk world into something more useful, and
where an adult should</font>
<br><font face="Comic Sans MS">begin this same journey.</font>
<p><font face="Comic Sans MS">perhaps I'm just a little bit lost in trying
to understand the best</font>
<br><font face="Comic Sans MS">progression for a learning programmer since
my first language was DCL.</font>
<br><font face="Comic Sans MS">you could say I had a broken programmer's
childhood and am now trying</font>
<br><font face="Comic Sans MS">to understand what a healthy one is like
:-)</font>
<p><font face="Comic Sans MS">my apologies if I have gone too far off topic
for this group...&nbsp; I'm</font>
<br><font face="Comic Sans MS">certainly interested in hearing about any
other more or equally</font>
<br><font face="Comic Sans MS">appropriate places to bring up these questions.</font>
<p><font face="Comic Sans MS">I guess at the heart of it, I'm trying to
figure out, in general,</font>
<br><font face="Comic Sans MS">what's the best answer to "I want to learn
how to program.&nbsp; where</font>
<br><font face="Comic Sans MS">should I start?", and in particular, what's
the best answer to "I want</font>
<br><font face="Comic Sans MS">to write CGIs for my web site.&nbsp; where
should I start learning?".&nbsp; I'm</font>
<br><font face="Comic Sans MS">also, however, trying to get a handle on
what it means for a language</font>
<br><font face="Comic Sans MS">or programming environment to be "intuitive"
or "easy".</font>
<p><font face="Comic Sans MS">andru</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS"><a href="mailto:luvisi@andru.sonoma.edu">luvisi@andru.sonoma.edu</a></font>
wrote in message ...
<p>>conjecture: Toon Talk is not capable of serving as a development
<br>>environment for all applications one will ever wish to create.&nbsp;
that
<br>>is, anyone who keeps programming long enough, and keeps making more
<br>>and more complex and/or functional programs will, eventually,
<br>>"outgrow" Toon Talk.
<br>>
<br>&nbsp;
<p>The current version of ToonTalk has many limitations and shortcomings.
Its
<br>ability to manipulate text strings is so-so. Its ability to do file
I/O is
<br>minimal. There are no floating point numbers. It requires a large and
slow
<br>programming environment to run programs. It currently is able to deal
with
<br>user media only as BMP or WAV files. You can re-train robots but you
can't
<br>edit their behavior. So, I would not try to build a web browser in
ToonTalk.
<br>The only reasonable way ToonTalk could be used for CGI programming
would be
<br>to build the program in ToonTalk and then use the Java translation
on the
<br>server.
<p>>if this conjecture is correct, I would be curious as to when/how you
<br>>(Ken Kahn) would expect a child who kept "doing more" to "outgrow"
<br>>Toon Talk.&nbsp; I would also be curious as to where you would recomend
<br>>they go when this happened.&nbsp; perhaps another way of putting this
is:
<br>>you clearly view Toon Talk as a "first step" in a progression... what
<br>>else do you see in that progression?
<br>>
<br>Maybe in a few years there will be a ToonTalk Pro or ToonTalk version
5.0
<br>(currently at 1.04) which won't be outgrown. In other words, I don't
see any
<br>reason to outgrow the core ideas of ToonTalk computation model and
<br>programming environment. It is only the current implementation that
might be
<br>outgrown.
<p>If a child mastered ToonTalk and wanted to do things it currently can't
do,
<br>I guess that Java is the best next step. I see ToonTalk's ability to
produce
<br>the Java equivalent of whatever a child has made as a bridge or stepping
<br>stone to make the transition to Java a bit easier.
<p>>
<br>>part of the reason I'm asking this is the same reason I started
<br>>following this newsgroup a couple weeks ago.&nbsp; I'm trying to understand
<br>>this amorpheous concept of "easy" as applied to computer use and
<br>>programming.&nbsp; also, can you name any other environments which
share
<br>>what you believe to be Toon Talk's most essential features?
<br>>
<p>This is a really good question and I hope others try to answer it as
well.
<br>One thing I've observed with kids and ToonTalk is that they very quickly
<br>learn the language primitives. Where they get stuck is they lack design
<br>skills - they know no programming techniques. This is how I feel when
I play
<br>with Lego Technic gears. I understand how gears work but I can't build
a
<br>very good Lego car.
<p>There are many languages that share ToonTalk's model of computation
-
<br>Concurrent Prolog, Parlog, Guarded Horn Clauses, Strand, KL1, OC, Herbrand,
<br>Janus, Linear Janus, and Oz. I think these languages aren't better
known
<br>because programmers have found them hard to learn. I suspect this is
mostly
<br>because programmers have already learned a very different way of thinking
<br>about programming.
<p>There are no other environments that I know of that enable you to do
general
<br>purpose programming within a game-like world. Robot Odyssey and Rocky's
<br>Boots (popular games from the early 1980s) let you express circuits
and
<br>boolean computations in a game-like world. Stagecast Creator (formerly
known
<br>as KidSim and Cocoa) makes it easy for kids to express some kinds of
<br>programs as picture re-write rules.
<p>>
<br>>...so I figured out that consistency is an important part of something
<br>>being "easy", but I know there's other things.
<br>>
<p>I think a good learnable language should have a small but powerful kernel.
<br>E.g. ToonTalk or Scheme. You then get consistency because most everything
<br>else is built upon the kernel.
<br>>
<br>>BASIC (is that a bad word here?), as I learned it on the apple II,
is
<br>>a very consistent language.&nbsp; it is also "easy" to grasp at first,
but
<br>>once a programmer starts trying to do anything requiring more than
a
<br>>couple thought processes to execute, he finds himself in spaghetti
<br>>code.
<p>Back in the 1970s and early 1980s BASIC was a bad word in the Logo
<br>community. But I don't know how the newer, better implementations of
Basic
<br>are viewed today. Visual Basic seems pretty reasonable these days -
it has
<br>recursive procedures, reasonable variable names, etc.
<p>>
<br>>C++, like perl, has all sorts of "magic" in it... the same expression
<br>>can mean all sorts of things depending on the context...
<br>>
<br>>I think C is a better first language than C++ because it has so much
<br>>less "magic",
<p>Interesting. By "magic" do you mean that the underlying mechanism is
complex
<br>and farther from the hardware? Would you argue against Java in the
same way?
<p>Best,
<p>-ken kahn (<a href="http://www.toontalk.com">www.toontalk.com</a>)
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From <a href="mailto:luvisi@andru.sonoma.edu">luvisi@andru.sonoma.edu</a>:</font>
<p><font face="Comic Sans MS">"Ken Kahn" &lt;<a href="mailto:KenKahn@ToonTalk.com">KenKahn@ToonTalk.com</a>>
writes:</font>
<br><font face="Comic Sans MS">> Maybe in a few years there will be a ToonTalk
Pro or ToonTalk version 5.0</font>
<br><font face="Comic Sans MS">> (currently at 1.04) which won't be outgrown.
In other words, I don't see any</font>
<br><font face="Comic Sans MS">> reason to outgrow the core ideas of ToonTalk
computation model and</font>
<br><font face="Comic Sans MS">> programming environment. It is only the
current implementation that might be</font>
<br><font face="Comic Sans MS">> outgrown.</font>
<p><font face="Comic Sans MS">ever plan to make it self hosting?&nbsp;
:-)</font>
<br>&nbsp;
<p><font face="Comic Sans MS">[snip]</font>
<br><font face="Comic Sans MS">> One thing I've observed with kids and
ToonTalk is that they very quickly</font>
<br><font face="Comic Sans MS">> learn the language primitives. Where they
get stuck is they lack design</font>
<br><font face="Comic Sans MS">> skills - they know no programming techniques.
This is how I feel when I play</font>
<br><font face="Comic Sans MS">> with Lego Technic gears. I understand
how gears work but I can't build a</font>
<br><font face="Comic Sans MS">> very good Lego car.</font>
<p><font face="Comic Sans MS">isn't that the way it is with anyone first
learning to program?&nbsp; I</font>
<br><font face="Comic Sans MS">remember an assignment from my first programming
course back in my</font>
<br><font face="Comic Sans MS">college days.&nbsp; we were to write a program
to ask the user to type in</font>
<br><font face="Comic Sans MS">words and the program would tell the user
if each word was a</font>
<br><font face="Comic Sans MS">palindrome or not.&nbsp; it was the first
assignment most of the students</font>
<br><font face="Comic Sans MS">had a problem with.&nbsp; to follow the
lego example, it was the first time</font>
<br><font face="Comic Sans MS">they had to build something rather than
prove they knew which part of</font>
<br><font face="Comic Sans MS">one lego fit into which part of the next.&nbsp;
the course was in C, and</font>
<br><font face="Comic Sans MS">everyone knew how to use loops, char arrays,
conditionals, and so on,</font>
<br><font face="Comic Sans MS">but they didn't have any idea how to start
putting them together.</font>
<br><font face="Comic Sans MS">this is the only intro to programming course
I've ever observed, not</font>
<br><font face="Comic Sans MS">being a teacher myself, so my sample is
a bit small, but I would not</font>
<br><font face="Comic Sans MS">be surprised to hear that what you describe
is a common pattern.</font>
<p><font face="Comic Sans MS">> There are many languages that share ToonTalk's
model of computation -</font>
<br><font face="Comic Sans MS">> Concurrent Prolog, Parlog, Guarded Horn
Clauses, Strand, KL1, OC, Herbrand,</font>
<br><font face="Comic Sans MS">> Janus, Linear Janus, and Oz. I think these
languages aren't better known</font>
<br><font face="Comic Sans MS">> because programmers have found them hard
to learn. I suspect this is mostly</font>
<br><font face="Comic Sans MS">> because programmers have already learned
a very different way of thinking</font>
<br><font face="Comic Sans MS">> about programming.</font>
<p><font face="Comic Sans MS">could you provide any urls or book recomendations?&nbsp;
as a professional</font>
<br><font face="Comic Sans MS">problem solver, and a human being in general,
I am always trying to</font>
<br><font face="Comic Sans MS">find new ways to look at problems.</font>
<p><font face="Comic Sans MS">> There are no other environments that I
know of that enable you to do general</font>
<br><font face="Comic Sans MS">> purpose programming within a game-like
world. Robot Odyssey and Rocky's</font>
<br><font face="Comic Sans MS">> Boots (popular games from the early 1980s)
let you express circuits and</font>
<br><font face="Comic Sans MS">> boolean computations in a game-like world.
Stagecast Creator (formerly known</font>
<br><font face="Comic Sans MS">> as KidSim and Cocoa) makes it easy for
kids to express some kinds of</font>
<br><font face="Comic Sans MS">> programs as picture re-write rules.</font>
<p><font face="Comic Sans MS">one hypothesis that bounced around in my
head was that logo wasn't</font>
<br><font face="Comic Sans MS">actually any easier than lisp.&nbsp; maybe
it's just that since it has such</font>
<br><font face="Comic Sans MS">a short initial "start typing" to "see something
cool" curve, kids are</font>
<br><font face="Comic Sans MS">more willing to put the effort into learning
logo since they receive</font>
<br><font face="Comic Sans MS">encouragement of a sort early on.</font>
<p><font face="Comic Sans MS">> I think a good learnable language should
have a small but powerful kernel.</font>
<br><font face="Comic Sans MS">> E.g. ToonTalk or Scheme. You then get
consistency because most everything</font>
<br><font face="Comic Sans MS">> else is built upon the kernel.</font>
<p><font face="Comic Sans MS">I've heard this about scheme many times before,
which is why I've</font>
<br><font face="Comic Sans MS">recently begun reading the standard.&nbsp;
one of the things that I've</font>
<br><font face="Comic Sans MS">found annoying about elisp is remembering
which builtins are special</font>
<br><font face="Comic Sans MS">forms/macros, and which ones are normal
functions.&nbsp; that is, if I want</font>
<br><font face="Comic Sans MS">to supply a function with a symbol, do I
quote the symbol, or not?</font>
<br><font face="Comic Sans MS">for instance, (setq hi "there") is the same
as (set 'hi "there").</font>
<p><font face="Comic Sans MS">> >C++, like perl, has all sorts of "magic"
in it... the same expression</font>
<br><font face="Comic Sans MS">> >can mean all sorts of things depending
on the context...</font>
<br><font face="Comic Sans MS">> ></font>
<br><font face="Comic Sans MS">> >I think C is a better first language
than C++ because it has so much</font>
<br><font face="Comic Sans MS">> >less "magic",</font>
<p><font face="Comic Sans MS">> Interesting. By "magic" do you mean that
the underlying mechanism is complex</font>
<br><font face="Comic Sans MS">> and farther from the hardware? Would you
argue against Java in the same way?</font>
<p><font face="Comic Sans MS">by magic, I mean weird, special case syntactic
sugar.&nbsp; I'm using it in</font>
<br><font face="Comic Sans MS">the sense that one would say "in perl, &lt;>
as the only condition in a</font>
<br><font face="Comic Sans MS">while loop is magic, sinse it does all these
special things."</font>
<br><font face="Comic Sans MS">...things which just don't make sense until
you've had enough real</font>
<br><font face="Comic Sans MS">world experience to see why they are valuable...</font>
<p><font face="Comic Sans MS">considder the difference between:</font>
<br><font face="Comic Sans MS">cout &lt;&lt; 2 &lt;&lt; 3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
==&nbsp;&nbsp;&nbsp; ( cout.operator&lt;&lt;( 2 ) ).operator&lt;&lt;( 2
);</font>
<br><font face="Comic Sans MS">=> 23</font>
<br><font face="Comic Sans MS">and:</font>
<br><font face="Comic Sans MS">cout &lt;&lt; (2 &lt;&lt; 3);&nbsp;&nbsp;&nbsp;
==&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cout.operator&lt;&lt;( 2 &lt;&lt;
3 );</font>
<br><font face="Comic Sans MS">=> 16</font>
<p><font face="Comic Sans MS">am I the only one who finds this a little
bit screwy?</font>
<p><font face="Comic Sans MS">properly used, operator overloading, function
overloading, and various</font>
<br><font face="Comic Sans MS">other features of C++ can be great.&nbsp;
while I would recomend C++ for</font>
<br><font face="Comic Sans MS">certain types of large projects, when used
by knowledgable and highly</font>
<br><font face="Comic Sans MS">competent programmers, I wouldn't currently
recomend it as a first</font>
<br><font face="Comic Sans MS">language.&nbsp; but then again, I'm still
forming my opinions on the</font>
<br><font face="Comic Sans MS">subject, and reserve the right to change
my mind at any time.</font>
<p><font face="Comic Sans MS">as far as java goes, the last time I touched
it was when it was brand</font>
<br><font face="Comic Sans MS">new, and while I was impressed with many
of the ideas in the language,</font>
<br><font face="Comic Sans MS">the implimentation kept crashing on everything
I wrote which was</font>
<br><font face="Comic Sans MS">longer than 50 lines or so, so I never got
really intimate with it...</font>
<p><font face="Comic Sans MS">giving it another try has been somewhere
near the middle of my todo</font>
<br><font face="Comic Sans MS">list for a while now.</font>
<p><font face="Comic Sans MS">thanks for the thoughtful responses,</font>
<br><font face="Comic Sans MS">andru</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS"><a href="mailto:luvisi@andru.sonoma.edu">luvisi@andru.sonoma.edu</a></font>
wrote in message ...
<br>>> There are many languages that share ToonTalk's model of computation
-
<br>>> Concurrent Prolog, Parlog, Guarded Horn Clauses, Strand, KL1, OC,
<br>Herbrand,
<br>>> Janus, Linear Janus, and Oz.
<p>>could you provide any urls or book recomendations?&nbsp; as a professional
<br>>problem solver, and a human being in general, I am always trying to
<br>>find new ways to look at problems.
<br>>
<p>Very good but theoretical:
<br>Concurrent Constraint Programming (Acm Doctoral Dissertation Awards)
<br>Vijay A. Saraswat / Hardcover / Published 1993
<br>Our Price: $55.00 (Special Order)
<br>Read more about this title...
<p>Haven't read it but I should. Looks good:
<br>Objects for Concurrent Constraint Programming (Kluwer International
Series
<br>in Engineering and Computer Science, 426)
<br>Martin Henz / Hardcover / Published 1997
<p>A bit old but a very good collection of papers:
<br>Concurrent Prolog : Collected Papers (Logic Programming Series)
<br>Ehud Shapiro(Editor) / Hardcover / Published 1988
<p>>
<br>>considder the difference between:
<br>>cout &lt;&lt; 2 &lt;&lt; 3;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ==&nbsp;&nbsp;&nbsp;
( cout.operator&lt;&lt;( 2 ) ).operator&lt;&lt;( 2 );
<br>>=> 23
<br>>and:
<br>>cout &lt;&lt; (2 &lt;&lt; 3);&nbsp;&nbsp;&nbsp; ==&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
cout.operator&lt;&lt;( 2 &lt;&lt; 3 );
<br>>=> 16
<br>>
<br>>am I the only one who finds this a little bit screwy?
<br>>
<br>&nbsp;
<p>Seeing this makes me glad that syntax errors and confusions are a non-issue
<br>for ToonTalk.
<p>Best,
<p>-ken kahn (<a href="http://www.toontalk.com">www.toontalk.com</a>)
<br>&nbsp;
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Brian Harvey:</font>
<p><font face="Comic Sans MS"><a href="mailto:luvisi@andru.sonoma.edu">luvisi@andru.sonoma.edu</a></font>
writes:
<br>>conjecture: Toon Talk is not capable of serving as a development
<br>>environment for all applications one will ever wish to create.&nbsp;
that
<br>>is, anyone who keeps programming long enough, and keeps making more
<br>>and more complex and/or functional programs will, eventually,
<br>>"outgrow" Toon Talk.
<p>Ken's answer to this was about the theoretical capabilities of the
<br>program, but what drives me crazy in TT is the user interface -- the
<br>fact that when you want to add two numbers you have to sit there for
<br>several seconds watching this funny-the-first-time animation of the
<br>rat with the hammer.&nbsp; The fact that I can't get the sorcerer's
<br>apprentice vacuum cleaner to stop deleting things!&nbsp; (I mean, I
can
<br>eventually, but not until it's eaten three things I wanted.)&nbsp;
Stuff
<br>like that.&nbsp; I bet kids outgrow that before they outgrow the set
of
<br>problems TT can program.
<p>>...so I figured out that consistency is an important part of something
<br>>being "easy", but I know there's other things.
<p>There's actually a good deal of disagreement among Logo people about
<br>the consistency question.&nbsp; The early MIT Logos (whence Terrapin
Logo
<br>and friends) have a BASIC-style IF/THEN special form.&nbsp; At LCSI
we
<br>decided to eliminate all special forms except TO; our IF is an ordinary
<br>procedure whose arguments must be quoted to avoid premature evaluation.
<br>MIT: IF 2=3 THEN PRINT "HELLO
<br>LCSI: IF 2=3 [PRINT "HELLO]
<br>I like the LCSI way better because it's more uniform and therefore
<br>easier to model, but I'm not sure it's "easier" for beginners.&nbsp;
It
<br>would be if the beginners were taught the model of applicative order
<br>evaluation, but they're not; they're taught "just remember to put
<br>brackets around the thing you want IF to run conditionally."&nbsp;
So it
<br>can *seem* to be *less* uniform!
<p>Aside from obvious dreadful mistakes, like the fact that STATIC means
<br>four, count them, four completely unrelated things in C++, I've come
<br>to believe that there's no such thing as easy or hard language features;
<br>it all depends on what you're used to.&nbsp; Well, maybe except for
call/cc
<br>in Scheme... that's hard... but when it comes to choosing a paradigm,
<br>functional is easiest if you're accustomed to doing math, but not
<br>otherwise, and I suspect some similar thing is true about concurrent
<br>programming.
<p>>&nbsp; frankly, [Logo] just reminded me of
<br>>elisp (the only lisp dialect I am very familiar with, though I know
a
<br>>*teeny* bit of scheme) with some different names, and '(...) replaced
<br>>with [...] and '... replaced with "... .
<br>>all the same concepts... recursion, variables, itteration via tail
<br>>recursion, minus things like non-argument local variables.
<p>I think Apple Logo II has LOCAL, doesn't it?
<p>But otherwise, indeed, Logo is basically Lisp.&nbsp; They left out the
<br>parentheses because they scare people; they added infix arithmetic.
<br>At the time Logo was designed, dynamic scope was standard for Lisp
<br>interpreters, so we didn't even have to think about that, although
<br>even today I stand by that choice for Logo.
<p>>-> what is it about logo (or any other language) that is supposed to
make
<br>>-> it "easy", and good as a first language?
<p>At the time, we argued that lists are more natural than arrays, because
<br>you don't have to count how big to make them, and you don't have to
<br>introduce index variables that really aren't relevant to your problem.
<br>Recursion is (we said) more natural than things like FOR loops,
<br>especially if you think in terms of little people (so that you focus
<br>on invocations, rather than on procedures).
<p>Also, a lot of design effort went into the error messages.&nbsp; It
was
<br>particularly easy to make fun of BASIC back then, which mostly said
<br>SYNTAX ERROR no matter what you did wrong.&nbsp; We had arguments about
<br>whether "I don't know how to XXX" is better or worse than "you don't
<br>say how to XXX" (that is, is it good or bad to personify the computer),
<br>and then there was Paul Goldenberg's brilliant idea to put an extra
<br>space in, as in "You don't say how&nbsp; to XXX" to help remind the
user
<br>that TO is what you use to fix it!
<p><img SRC="../rainbow.gif" height=6 width=623>
<p><font face="Comic Sans MS">From Ken Kahn:</font>
<p><font face="Comic Sans MS">Brian Harvey wrote in message &lt;<a href="mailto:74cgpg$4sr$1@agate.berkeley.edu">74cgpg$4sr$1@agate.berkeley.edu</a>>...</font>
<p><font face="Comic Sans MS">>Ken's answer to this was about the theoretical
capabilities of the</font>
<br><font face="Comic Sans MS">>program, but what drives me crazy in TT
is the user interface -- the</font>
<br><font face="Comic Sans MS">>fact that when you want to add two numbers
you have to sit there for</font>
<br><font face="Comic Sans MS">>several seconds watching this funny-the-first-time
animation of the</font>
<br><font face="Comic Sans MS">>rat with the hammer.&nbsp; The fact that
I can't get the sorcerer's</font>
<br><font face="Comic Sans MS">>apprentice vacuum cleaner to stop deleting
things!&nbsp; (I mean, I can</font>
<br><font face="Comic Sans MS">>eventually, but not until it's eaten three
things I wanted.)&nbsp; Stuff</font>
<br><font face="Comic Sans MS">>like that.&nbsp; I bet kids outgrow that
before they outgrow the set of</font>
<br><font face="Comic Sans MS">>problems TT can program.</font>
<br><font face="Comic Sans MS">></font>
<br><font face="Comic Sans MS">Kids adapt rather than outgrow. And there
are good reasons why the interface</font>
<br><font face="Comic Sans MS">is the way it is. If you had to wait every
time for the mouse with a hammer,</font>
<br><font face="Comic Sans MS">then I would agree with you. But ToonTalk
isn't just a concurrent</font>
<br><font face="Comic Sans MS">programming system, it is a concurrent programming
environment as well. You</font>
<br><font face="Comic Sans MS">can drop a number on a number and start
working on the next thing, confident</font>
<br><font face="Comic Sans MS">that the mouse will add them together while
you are doing the next thing.</font>
<br><font face="Comic Sans MS">There was a time when the vacuum cleaner
vacuumed up one thing when you</font>
<br><font face="Comic Sans MS">turned him on. But real vacuums stay on
until you turn them off. And the</font>
<br><font face="Comic Sans MS">bike pump has an even stronger need to be
on until you turn him off. You</font>
<br><font face="Comic Sans MS">want to slowly change the dimensions of
something until it is the way you</font>
<br><font face="Comic Sans MS">want and then stop pumping.</font>
<p><font face="Comic Sans MS">The only kid who I've heard complain about
the interface was 14 years old.</font>
<br><font face="Comic Sans MS">And you were there last month, when a 9
year old at the BayCHI Kids meeting</font>
<br><font face="Comic Sans MS">walked up to ToonTalk "cold" and did very
well with it without help.</font>
<p><font face="Comic Sans MS">Best,</font>
<p><font face="Comic Sans MS">-ken kahn (<a href="http://www.toontalk.com">www.toontalk.com</a>)</font>
<p><img SRC="../rainbow.gif" height=6 width=623>
<center>
<p><font face="Comic Sans MS"><font size=-1><a href="toontalk.htm">home</a>
| <a href="search.htm">search</a> | <a href="buy.htm">purchase</a> | <a href="doc.htm">manual</a>
| <a href="whatsnew.htm">news</a> | <a href="infodesk.htm">info</a> | <a href="faq.htm">faq</a>
| <a href="support.htm">support</a> | <a href="free.htm">downloads</a>
| <a href="press.htm">press</a> | <a href="address.htm">contact us</a></font></font></center>

<p><br>
</body>
</html>
