<html>
<head>
<title>ToonTalk - Nos bastidores do jogo de Desafio</title>
<link rel="stylesheet" type="text/css" href="ToonTalk.css">
</head>

<body link="#0000ff" vlink="#800080" bgcolor="#ffffff">

<div align="center">
<a name="topo"></a>
<table width=468 cellspacing=0 cellpadding=0 border=0><tr><td>

<p>
<table cellspacing=0 cellpadding=0 border=0><tr>
          <td>
<div align=center>
<A class=menu href="toontalk.html" onmouseover="window.status=' Início'; return true">início</A><span class=bola> •</span>
<A class=menu href="search.html" onmouseover="window.status=' Busca'; return true">busca</A><span class=bola> •</span>
<A class=menu href="buy.html" onmouseover="window.status=' Compra'; return true">compra</A><span class=bola> 
                        •</span>
<A class=menu href="doc.html" onmouseover="window.status=' Manual'; return true">manual</A><span class=bola> 
                        •</span>
<A class=menu href="whatsnew.html" onmouseover="window.status=' Novidades'; return true">novidades</A><span class=bola> •</span>
<A class=menu href="faq.html" onmouseover="window.status=' Dúvidas'; return true">dúvidas</A><span class=bola> •</span>
<A class=menu href="support.html" onmouseover="window.status=' Suporte'; return true">suporte</A><span class=bola> •</span>
<A class=menu href="free.html" onmouseover="window.status=' Download'; return true">download</A><span class=bola> •</span>
<A class=menu href="press.html" onmouseover="window.status=' Imprensa'; return true">imprensa</A><span class=bola> •</span>
<A class=menu href="address.html" onmouseover="window.status=' Contato'; return true">contato</A>
<hr size=1></div>
    </td></tr>
</table>

<h2>O que há por trás ds desafios</h2>

<p>A seguir daremos uma olhada no que há 
            por trás dos desafios <U>no</U>        
                 ToonTalk. Você está imaginando como está aprendendo programação de computadores enquanto se diverte? Dê uma olhada nas explicações de cada desafio e você se surpreenderá com o quanto aprendeu ou pode aprender enquanto está jogando ToonTalk.

<p class=center><br><b><i>Nível 1- 
            Números (geralmente potências de 2)</i></b>

<p><b><U>Desafio</U> n°1 - Márcio precisa de uma caixa com um 1 e um 2 dentro.</b> 
            Isto introduz as caixas do ToonTalk que servem para guardar coisas. Os cientistas da computação as chamam <i>estruturas de dados</i>. As caixas quase se parecem com o que eles chamam <i>bancos de dados</i>, <i>vetores</i> e <i>"tuples"</i>. Os <U>números</U>   são um exemplo do que os cientistas da computação chamam <i>tipos de dados atômicos</i>. Para resolver esse desafio você precisa descobrir como colocar coisas em caixas (ou seja, como <i>inicializar elementos de um vetor</i>).

<p><b><b><U>Desafio</U>              </b> n°2 - Márcio precisa de um 4.</b> Este 
            desafio introduz Bambam, o ratinho, que faz 
            cálculos aritméticos e outras operações básicas. Através da solução desse desafio você descobrirá como expressar a adição de dois números.

<p><b><b><U>Desafio</U>              </b> n°3 - Márcio precisa de uma caixa  com um 8, um 16 e um 32 dentro.</b> Este introduz um modo de combinar caixas para fazer 
            caixas maiores. Ele também ilustra como expressar a adição de um número que está em uma caixa. Na terminologia da ciência da computação você aprende como<i>concatenar vetores</i> e como <i>operar um elemento de uma estrutura de dados</i>.

<p><b><b> 
                     Desafio&nbsp;</b> 
            n°4 - Márcio precisa de um número maior que 1.000.</b> Este desafio introduz a Varinha 
            Mágica do ToonTalk, que é usada para copiar os objetos do ToonTalk. Como todas as ferramentas do ToonTalk, a varinha pode ser utilizada como parte de um programa e como uma ferramenta no interior do ambiente de programação. Este desafio é matematicamente interessante já que se baseia em repetidas multiplicações para crescer de 1 até 1.024 em apenas 10 passos. Ele é, intencionalmente, um pouco tedioso, para proporcionar a motivação para automatizar tarefas como essa última.

<p><b><b><b> 
                     Desafio</b> 
                     </b> n°5 - Márcio precisa de um zero.</b> Este 
            desafio introduz Asper, o aspirador. Asper é uma ferramenta utilizada para remover coisas. O zero está enterrado sob coisas que apenas Asper pode remover.

<p><b><b><b>Desafio </b></b> n°6 -  Márcio precisa de - 1.</b> Para resolver esse 
            desafio o jogador precisa adivinhar (ou receber pistas de Márcio) que o botão no nariz de Asper pode ser alterado pressionando-o. Esta utilização dos botões para alterar o comportamento das ferramentas é utilizada por toda parte no ToonTalk. Um jogador observador pode perceber que esta utilização de Asper para sugar coisas e depois cuspi-las corresponde bastante a <i>recortar e colar</i> em muitas interfaces baseadas em janelas (windows). 

<p><b><b><b>Desafio </b></b> 
            n°7 - Márcio precisa de um grupo de números em branco.</b> Este desafio introduz grupos de números em branco que são usados em desafios posteriores. Um grupo de números em branco é uma forma de expressar o <i>tipo de uma estrutura de dados</i>. Neste caso, ele indica alguns dados cujo <i>tipo</i> é o <i>número</i>.

<p><b><b><b>Desafio </b></b> n°8 - Márcio precisa de uma caixa com dois zeros.</b> 
            Treinando o robô neste desafio, você estará construindo seu primeiro programa. O programa construído é equivalente a um programa de texto como este:

<p>while (sizeOf(box) = 1 and box[0] = 1) do

<blockquote>
  <p>box := concat(box, copy(box));&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;< /p>  
</blockquote>

<p>endwhile;

<p>O motivo que permite que mesmo 
            crianças pequenas possam construir esse programa sem ajuda é que o desafio restringe o universo de forma que a busca que o jogador precisa fazer para encontrar a solução não é muito grande. Aqui a memória do robô é limitada para lembrar apenas dois passos, e o robô já tem a Varinha Mágica.

<p><b><b><b>Desafio </b></b> 
            n°9 - Márcio precisa de um número maior que um bilhão.</b> A solução deste 
            desafio se baseia na experiência da 
            solução dos problemas 4, 7 e 8. Para resolver este 
            desafio você precisa treinar um robô para fazer o que você fez manualmente no desafio n°4. Durante o desafio n°4 você teve de repetir uma seqüência de ações dez vezes. Aqui você simplesmente treina o robô para realizar uma seqüência e ele irá fazê-la pelas 30 vezes necessárias. De forma a conseguir que o robô trabalhe repetidamente, você precisa aprender a como tornar o robô menos preocupado acerca do tipo de caixa em que irá trabalhar. No jargão da ciência da computação isto se chama <i>relaxamento do predicado da condicional</i>. O programa de 
            texto equivalente ao robô treinado nesse desafio é:

<p>repeat 30

<blockquote>
  <p>if (sizeOf(box) = 1 and  isNumber(box[0])) then&lt;  /p &gt;&lt;  /p &gt;&lt;  /p &gt;&lt;  /p &gt;&lt; /p 
                &gt;< /p >     
</blockquote>

<blockquote>
  <blockquote>
    <p>Box[0] := box[0] + copy(box[0]);&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;< /p>   
  </blockquote>
  <p>endif;</p>
</blockquote>

<p><b><b><b>Desafio </b></b> n°10 - Márcio precisa de uma caixa dentro da caixa.</b> 
            Para resolver esse desafio, você precisa colocar uma caixa dentro de uma caixa dentro de uma caixa. Isto é o que os cientistas da computação chamam de uma <i>estrutura de dados recursiva, desde que os elementos da estrutura podem ser do mesmo tipo que toda a estrutura.</i> Se você colocar uma das caixas no buraco errado, então Márcio o informará que os elementos precisam estar no lugar correto. Isto porque a caixa é <i>uma coleção indexada ordenada.</i>


<p><b><b><b>Desafio</b></b> n°11 - Márcio precisa de uma caixa com 3 zeros.</b> Como 
            o desafio n°2, você precisa conectar <i>(concatenar)</i> duas caixas <i>(vetores)</i>. Aqui você descobrirá que as caixas 
            não podem ser conectadas quando elas são parte de outra caixa. Você descobre que as caixas podem ser removidas, conectadas, e então colocadas de volta. Uma solução corresponde ao fragmento de código:

<p>temp1 := box[0];

<p>temp2 := box[1];

<p>temp1 := concat(temp1,temp2);

<p>box[1] := temp1;

<p><b><b><b>Desafio</b></b> n°12 - Márcio precisa de uma caixa com 6 zeros.</b> Este 
            desafio se assemelha ao n°11. A operação de conectar as caixas é repetida três vezes. Isto serve para prepará-lo para o próximo desafio no qual um robô precisa ser treinado para repetidamente conectar caixas.

<p><b><b><b>Desafio</b></b> n°13 - Márcio precisa de uma caixa com 10 zeros.</b> Na 
            solução deste desafio, você 
            treinará um robô para aumentar repetidamente uma caixa. Isto introduz uma técnica de programação habitualmente usada quando se incrementa a criação de uma estrutura de dados. O robô treinado corresponde ao programa de texto:

<p>repeat 4

<blockquote>
  <p>if (sizeOf(box) = 2 and sizeOf(box[0]) =                     1 and
  box[0][0] = 0) then
  <blockquote>
    <p>temp1 := copy(box[0]);
    <p>temp1 := concat(temp1,box[1]);
    <p>box[1] := temp;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;< /p> 
  </blockquote>
  <p>endif;</p>
</blockquote>

<p>O robô neste desafio pode se lembrar de até 20 passos,   mas o desafio pode ser resolvido com apenas quatro.

<p><b><b><b>Desafio</b></b> n°14 - Márcio precisa de uma caixa contendo 1, 2, 4, 8, 16 e 32.</b> A resolução desse desafio envolve o aumento repetido de uma caixa com números que são o dobro do número anterior.

<p><b><b><b>Desafio</b></b> 
            n°15 - Márcio precisa de uma caixa contendo 1, 2, 4, 8, 16 e assim por diante até atingir 1.073.741.824.</b> A 
            solução desse problema se baseia nos desafios n°9, n°13 e n°14. Ele é um bom exemplo de como alguém freqüentemente precisa combinar diferentes técnicas de programação para atingir um objetivo. Aqui está o equivalente programa de texto:

<p>repeat 30

<blockquote>
  <p>if (sizeOf(box) = 2 and sizeOf(box[0]) =                     1 and
  isNumber(box[0][0])) then
  <blockquote>
    <p>box[0][0] := box[0][0] + copy(box[0][0]);
    <p>temp1 := copy(box[0]);
    <p>temp2 := box[1];
    <p>temp2 := concat(temp2,temp1);
    <p>box[1] := temp2;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;< /p> 
  </blockquote>
  <p>endif;</p>
</blockquote>

<p><b><b><b>Desafio</b></b> n°16 - Márcio precisa do ano em que você nasceu.</b> As potências de 2 são o conjunto 
            básico dos inteiros positivos. Em outras palavras, qualquer número inteiro pode ser expresso como a soma de números que são potência de 2 e nenhum número na soma ocorre mais de uma vez. Daí a ausência da Varinha Mágica neste desafio.

<p><b><b><b>Desafio</b></b> 
            n°17 - Márcio precisa do ano em que você nasceu em binário.</b> Você precisa fazer exatamente a mesma 
            coisa que ele ou ela fizeram quando resolveram o desafio n°17. Este pode ser na verdade um desafio muito mais fácil que o n°16. O truque é perceber que sempre que precisar de um 1, encontre o número com o 1 naquela posição.

<p><b>Desafios n°18, n°19 e n°20</b> -
Intencionalmente deixados em branco.

<p class=center><br><b><i>Nível 2 - Letras e Palavras</i></b>

<p><b><b><b>Desafio</b></b> n°21 - Márcio precisa de uma caixa com A, B e C.</b> Este 
            desafio introduz grupos de texto (<i>um novo tipo de dados</i>). Ao solucioná-lo, você 
            irá descobrir o que faz a operação de adição quando aplicada às letras

<p><b><b><b>Desafio</b></b> n°22 - Márcio precisa de uma caixa com A, B, C, D, E e F.</b> este desafio é similar ao 
            desafio n°14, mas a mesma técnica é aplicada agora às letras, ao invés de números.

<p><b><b><b>Desafio</b></b> 
            n°23 - Márcio precisa de uma caixa com A, B, C, e assim por diante até Z.</b> Este desafio se baseia nos desafios n°15 e n°22. Como no n°15, você precisa treinar um robô para dar um passo, de tal forma que quando ele o tiver feito estará pronto para dar o próximo passo. O programa de texto equivalente é:

<p>repeat 20 

<blockquote>
  <p>if (sizeOf(box) = 3 and box[0] = 1 and
  sizeOf(box[1]) = 1 and isText(box[1][0])) then
  <blockquote>
    <p>temp1 := copy(box[1]);
    <p>box[1][0] := box[1][0] + copy(box[0]);
    <p>temp2 := box[2];
    <p>temp2 := concat(temp2,temp1);
    <p>box[2] := temp2;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;< /p> 
  </blockquote>
  <p>endif;</p>
</blockquote>

<p><b><b><b>Desafio</b></b> 
            n°24 - Márcio precisa de uma caixa com a, b, c, e assim por diante até z.</b> Este desafio é 
            trivial porque o robô que foi treinado no desafio anterior pode criar a caixa que aqui é necessária. Tudo o que o robô necessita é receber uma caixa diferente para começar. Um robô é o que é chamado pelos cientistas da computação de <i>uma procedura</i> . E <i>esta procedura</i> tem um <i>argumento</i> 
            - a caixa que é dada para o robô. Um aspecto muito importante de uma procedura é que ela pode ser reutilizada pela <i>transmissão</i> de diferentes <i>argumentos</i>.

<p><b><b><b>Desafio</b></b> 
            n°25 - Márcio precisa de uma caixa com um alfabeto que é pequeno o bastante para que seja visto todo de uma só vez.</b> Este desafio introduz uma nova 
            ferramenta – Soprana, a bomba de bicicleta. Soprana muda o tamanho das coisas. Isto é útil em "Free Play" ( Jogo Livre) para gerenciar o estado real da tela. É também um meio simples e direto de alterar o tamanho das ilustrações.

<p><b><b><b>Desafio</b></b> 
            n°26 - Márcio precisa de uma caixa com um ponto final, ponto de interrogação e vírgula.</b> Este 
            desafio ilustra que os grupos de texto não 
            são limitados às letras do alfabeto, mas também incluem a pontuação. As letras, pontuação e símbolos especiais ( como o $) são chamados de <i>caracteres</i> na 
            maioria das linguagens de programação. Este desafio também ilustra dramaticamente que o tamanho dos objetos no ToonTalk não influencia em como eles se comportam ( <i>sua semântica</i>).

<p><b><b><b>Desafio</b></b> 
            n°27 - Márcio precisa que a caixa com a pontuação seja grande o bastante para que veja seu conteúdo.</b> Este desafio introduz uma <i>tecla de atalho</i> – neste caso, um meio de criar um som para chamar Pumpy para saltar em sua mão. As teclas de atalho são comuns em muitas espécies diferentes de interfaces do usuário.

<p><b><b><b>Desafio</b></b> 
            n°28 - Márcio precisa da palavra "Start" (Início).</b> Este desafio apresenta o que os cientistas da computação denominam <i>strings</i> – ou seja, <i>seqüências de caracteres</i>. Para resolver esse 
            desafio você precisa descobrir que as letras e "strings" podem ser concatenados para formar "strings" (seqüências) maiores.

<p><b><b><b>Desafio</b></b> n°29 e n°30</b> - Intencionalmente deixados em branco.

<p class=center><br><b><i>Nível 3 - Matemática do Tempo</i></b>

<p><b><b><b>Desafio</b></b> 
            n°31 - Márcio precisa de uma caixa com o seu aniversário.</b> Para resolver este desafio, 
            você precisa descobrir que o teclado pode ser utilizado para alterar o valor de "strings" e números. Isto é uma espécie de <i>manipulação direta de dados</i>.

<p><b><b><b>Desafio</b></b> 
            n°32 - Márcio quer saber o número de minutos de um dia.</b> Este desafio ilustra que a 
            adição repetida é multiplicação. O programa de texto equivalente é :

<p>repeat 24

<blockquote>
  <p>if (sizeOf(box) = 2 and isNumber(box[0]) and
  isNumber(box[1])) then
  <blockquote>
    <p>box[1] := box[1] + copy(box[0]);&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;< /p>   
  </blockquote>
  <p>endif;</p>
</blockquote>

<p><b><b><b>Desafio</b></b> 
            n°33 - Márcio quer saber o número de segundos em uma hora.</b> O robô do desafio n°32 é reutilizado aqui, pois a única diferença é quantas vezes as instruções devem ser repetidas.

<p><b><b><b>Desafio</b></b> 
            n°34 - Márcio  precisa de uma caixa que exiba um conjunto de escalas que mostre que dois números são o mesmo.</b> Este desafio introduz escalas que são um meio de expressar <i>comparações numéricas</i>. Ele 
            também introduz o uso de números negativos para a subtração.

<p><b><b><b>Desafio</b></b> 
            n°35 - Márcio precisa de outra caixa com uma escala mostrando que dois números são o mesmo.</b> Este 
            desafio difere do anterior, porque agora um robô 
            está fazendo o trabalho. O que é importante notar aqui é que o robô pára quando a escala não é mais graduada à esquerda. Este exemplo mostra como utilizar um predicado de comparação em uma condicional. Desde que o robô possui uma varinha com mágica ilimitada, ele pára apenas quando a caixa não mais se identifica com a caixa em seu balão de pensamento. Isso é o que os cientistas da computação chamam de um <i>"while loop"</i>. O equivalente de texto é:

<p>while (sizeof(box) = 4 and box[1] = '&gt;' and
isNumber(box[0]) and isNumber(box[2]) and isNumber(box[3])) then

<blockquote>
  <p>box[2] := box[2] + copy(box[3]);&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;< /p>   
</blockquote>

<p>endwhile;

<p>The expression "box[1]
= '&gt;' " is unusual. In this case it is equivalent
to the more common "box[0] &gt; box[2]", since the scale is always displaying the relationship between
its neighboring data.

<p><b><b><b>Desafio</b></b> n°36 - Márcio precisa de uma caixa com 24 zeros.</b> Este 
            desafio combina o n°13 e o n°35. Ele mostra como utilizar um <i>"while loop"</i> com uma <i>expressão em linguagem de computação</i>. Esta é uma técnica 
            importante para repetir alguma coisa um número de vezes quando você não sabe quantas vezes será necessário repeti-la até que o programa rode.

<p>Os cientistas da computação 
            analisam programas para encontrar constantes. Existem relações que se mantêm depois de cada ciclo. Aqui é uma constante que o primeiro buraco da caixa é um número que é o tamanho (isto é, o número de buracos) da caixa no sexto buraco.  O equivalente de texto do robô é :

<p>while (sizeof(box) = 6 and box[1] = '&lt;' and
isNumber(box[0]) and isNumber(box[2]) and isNumber(box[3])) do

<blockquote>
  <p>temp1 := copy(box[4]);
  <p>temp2 := box[5];
  <p>temp2 := concat(temp2,temp1);
  <p>box[5] := temp2;
  <p>box[0] := box[0] + copy(box[3]);&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;< /p>   
</blockquote>

<p>endwhile;

<p>ou equivalentemente:

<p>if (sizeof(box) = 6 and box[1] = '&lt;' and
isNumber(box[0]) and isNumber(box[2]) and isNumber(box[3])) then

<blockquote>
  <p>for (; box[0] &lt; box[2]; box[0] :=                               box[0] +
  copy(box[3])) do
  <blockquote>
    <p>temp1 := copy(box[4]);
    <p>temp2 := box[5];
    <p>temp2 := concat(temp2,temp1);
    <p>box[5] := temp2;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;< /p> 
  </blockquote>
  <p>endfor;</p>
</blockquote>

<p>endif;

<p><b><b><b>Desafio</b></b> n°37 - Márcio quer saber quantas horas existem em um ano.</b> Este é similar ao desafio n°32, 
            exceto que agora você está treinando um robô 
            geralmente mais útil. Isto é porque o robô computa o produto dos dois primeiros números e o mantém no sexto buraco. A constante neste programa é que o número no sexto buraco é o produto dos números no primeiro e quarto buracos. O robô pára quando os números no segundo e no quarto buraco são os mesmos. O equivalente de texto disso é:

<p>while (sizeof(box) = 6 and box[1] &gt; box[3] and
isNumber(box[0]) and isNumber(box[1]) and isNumber(box[3]) and isNumber(box[4]) and
isNumber(box[5])) do

<blockquote>
  <p>box[5] := box[5] + copy(box[0]);
  <p>box[3] := box[3] + copy(box[4]);&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;< /p>   
</blockquote>

<p>endwhile;

<p><b><b><b>Desafio</b></b> 
            n°38 - Márcio quer saber quantos segundos há em um dia.</b> Para resolver esse desafio, você utiliza 
            o robô treinado no desafio anterior para 
            multiplicar 60 vezes 24, resultando em 1.440. O jogador então utiliza o robô novamente para multiplicar 60 vezes 1.440. Isto pode ser feito colocando o 60 tanto no primeiro como no segundo buraco e o 1.440 no outro. O robô irá computar o produto corretamente em qualquer um dos casos, mas ele será muito mais rápido se o 1.440 estiver no primeiro buraco. Isto acontece porque o robô multiplica através da adição repetida do primeiro número. A quantidade de trabalho que o robô precisa fazer é proporcional ao número no segundo buraco. Em terminologia da ciência da computação, nós dizemos que a <i>complexidade do programa é linear com o segundo argumento</i>.

<p><b><b><b>Desafio</b></b> 
            n°39 - Márcio quer saber quantos segundos há em um ano.</b> Como no desafio anterior, este utiliza repetidamente o robô treinado no desafio n°37 para computar 365x24x60x60.

<p><b><b><b>Desafio</b></b> n°40</b> - Intencionalmente deixado em branco.

<p class=center><br><b><i>Nível 4 - Computando o Tempo</i></b>

<p><b><b><b>Desafio</b></b> n°41 - Márcio precisa dos dias da semana.</b> Este 
            desafio introduz os Pombos e seus ninhos. Para um cientista da computação um pombo e seu ninho é um <i>canal de 
            comunicação</i>. Um pombo é o <i>direito ou capacidade para enviar mensagens em um canal</i> e seu <i>ninho o direito de receber mensagens naquele canal</i>. Este exemplo também ilustra que as mensagens no ToonTalk são <i>enfileiradas de um modo primeira a chegar, primeira a sair</i>.

<p><b><b><b>Desafio</b></b> n°42 - Márcio  precisa de uma caixa com um ninho com inteiros começando de 2.</b> O robô treinado para 
            resolver este desafio é o que os cientistas da computação chamam um <i>gerador</i>. Aqui o robô gera um <i>fluxo de inteiros</i>. Este gerador é um <i>gerador infinito</i>, desde que ele não pára. O equivalente de texto desse robô é :

<p>while (sizeOf(box) = 3 and isNumber(box[0]) and
isNumber(box[1]) and isSendCapability(box[2])) do

<blockquote>
  <p>transmit(box[2],copy(box[0])); <em>// transmit a
  copy of box[0] on the channel of box[2]</em>
  <p>box[0] := box[0]+copy(box[1]);&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;< /p> 
</blockquote>

<p>endwhile;

<p><b><b><b>Desafio</b></b> 
            n°43 - Márcio precisa da soma dos números no ninho.</b> Aqui você treina um robô para ser um <i>consumidor</i>. Muitos <i>programas orientados para fluxos</i> envolvem <i>consumidores</i> e <i>geradores</i>.

<p>while (sizeOf(box) = 2 and isNumber(peek(box[0]))
and isNumber(box[1])) do

<blockquote>
  <p><em>// we "peek" at the communication
  channel in box[0] to see if a number is there</em>
  <p>box[1] := box[1] + receive(box[0]); 
  <p><em>// "receive" removes the top element
  in the queue and returns it</em></p>
</blockquote>

<p>endwhile;

<p><b><b><b>Desafio</b></b> 
            n°44 - Márcio precisa de uma caixa com três números que não se alteram.</b> Aqui, você 
            é apresentado aos sensores. Um sensor é atualizado a 
            cada ciclo, e portanto exibe o valor mais recente daquilo que está aferindo. O que um sensor está aferindo pretende-se que seja um mistério até o desafio n°48. Este desafio ensina a técnica de programação do ToonTalk de "congelar um sensor", descendo-o a zero.

<p><b><b><b>Desafio</b></b> 
            n°45 - Maty precisa de uma caixa com um ninho cheio de números que não se alteram.</b> Este 
            desafio combina os desafios n°42 e n°44 para produzir um <i>fluxo de valores de sensor</i>. O equivalente de texto é:

<p>while (sizeOf(box) = 3 and isNumber(box[0]) and
isSendCapability(box[1]) and box[2] = 0) do

<blockquote>
  <p>temp1 := copy(box[2]);
  <p>temp1 := temp1 + copy(box[0]);
  <p>transmit(box[1],temp1);</p>
</blockquote>

<p>endwhile;

<p><b><b><b>Desafio</b></b> 
            n°46 - Márcio quer saber a soma dos números no ninho.</b> O robô treinado no desafio n°43 trabalhará bem com este fluxo de números.

<p><b><b><b>Desafio</b></b> 
            n°47 - Márcio quer o número que resulta da espera por 8 segundos.</b> Here you run the robot from puzzle #43 and the
robot from puzzle #45 <i>in parallel</i>, in other words, at the same time.

<p>Para resolver este desafio, 
            você precisa gerar um novo processo carregando o 
            caminhão com um robô e uma caixa. Este é o 
            método favorito de rodar programas em paralelo – fazendo-o em uma única casa é mais difícil de controlar e se confunde rapidamente. Aqui você aprende que o sensor mede o número de milissegundos  desde o último ciclo do ToonTalk. Portanto a soma dos números mede quanto tempo passou. Se você deixou por exatamente 8 segundos no desafio n°47, o número seria 8.000. Aqui, se você esperou por exatamente 14 segundos o número seria 14.000. A razão pela qual você deve estar fora do ângulo de visão é que os pombos baixam vagarosamente para seu benefício, portanto você pode observá-los. Os pombos lentos interferem aqui com a medição do tempo precisamente.

<p><b><b><b>Desafio</b></b> n°49 - Márcio quer que você se livre da outra casa.</b> Para resolver este desafio você precisa descobrir como <i>terminar um processo</i>.

<p><b><b><b>Desafio</b></b> n°50 - Márcio quer o resultado depois de esperar 10 segundos.</b> Desta vez você precisa treinar um único 
            robô para fazer o que os robôs nos desafios n°47 e n°48 fizeram.Os programadores freqüentemente fazem um programa especial que faz o mesmo que uma combinação de dois programas gerais. Eles o fazem pois o computadores necessitam dar menos passos para rodar o programa especial. Aqui os processos gerador e consumidor podem ser combinados em um processo mais rápido e muito mais simples. O equivalente de texto é:

<p>while (sizeOf(box) = 2 and isNumber(box[1]) and
isNumber(box[2])) do

<blockquote>
  <p>box[1] := box[1] + copy(box[0]);&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;< /p>   
</blockquote>

<p>endwhile;

<p><b><b><b>Desafio</b></b> 
            n°51 - Márcio precisa da caixa depois de três segundos que o cronômetro foi desligado.</b> Este 
            desafio combina os desafios n°35 e n°50 para medir o tempo até que alguma comparação não seja mais verdadeira. Aqui está a forma de texto:

<p>while (sizeOf(box) = 6 and isNumber(box[0]) and
isNumber(box[1]) and isNumber(box[3])and box[1] &lt; box[3]) do

<blockquote>
  <p>box[3] := box[3] + milliseconds_since_last_cycle();&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; 
                /p&gt;< /p>   
</blockquote>

<p>endwhile;

<p><b><b><b>Desafio</b></b> n°52 - Márcio precisa de - 10.</b> Este 
            desafio ilustra o uso repetido de -1 para o <i>decremento de um contador</i>. É 
            igualmente válido ver esta atividade como  a adição de um número negativo ou a subtração de um positivo. O equivalente de texto é:

<p>while (sizeOf(box) = 3 and isNumber(box[0]) and
isNumber(box[1])) do

<blockquote>
  <p>box[0] := box[0] + copy(box[1]);&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;< /p>   
</blockquote>

<p>endwhile;

<p><b><b><b>Desafio</b></b> n°53 - Márcio quer a palavra secreta.</b> Este 
            desafio introduz equipes de robôs. Quando uma 
            caixa é dada a um robô, e essa caixa não combina com a caixa no balão de pensamento do robô, então o robô deixará a caixa para o próximo robô da equipe, se houver um.
Em procedimentos de linguagens de programação, isso corresponde ao que os cientistas da computação chamam de <i>instruções se- então</i>. Em linguagens de programação orientadas para objetos, uma equipe corresponde ao <i>comportamento de um objeto</i>, onde cada robô corresponde a um <i>método</i>. Na lógica de linguagens de programação, uma equipe corresponde a um <i>predicado</i>, e cada robô a uma <i>condicional</i>. A equipe construída neste desafio é equivalente ao seguinte programa de texto de procedimento:

<p>procedure team(Box box)

<blockquote>
  <p>if (sizeOf(box) = 3 and box[0] = 0 and box[1] =     -1
  and box[2] = 'a') then
  <blockquote>
    <p>run_secret_procedure(box);</p>
  </blockquote>
  <blockquote>
    <p>team(box);</p>
  </blockquote>
  <p>else if (sizeOf(box) = 3 and isNumber(box[0]) and
  isNumber(box[1])) then
  <blockquote>
    <p>box[0] := box[0] + copy(box[1]);
    <p>team(box);</p>
  </blockquote>
  <p>endif;</p>
</blockquote>

<p>endprocedure;

<p><b><b><b>Desafio</b></b> n°54 - Márcio quer um despertador.</b> Aqui o robô 
            treinado para o desafio n°51 é uitlizado junto àquele treinado aqui para implementar uma mensagem enviada com o atraso de um número de segundos. O programa de texto equivalente é:

<p>procedure team(Box box)

<blockquote>
  <p>if&nbsp; (sizeOf(box) = 6 and isNumber(box[0]) and
  isNumber(box[1]) and isNumber(box[3])and box[1] &lt; box[3]) then
  <blockquote>
    <p>box[3] := box[3] + milliseconds_since_last_cycle();
    <p>team(box);</p>
  </blockquote>
  <p>else if&nbsp; (sizeOf(box) = 6 and isNumber(box[0])
  and isNumber(box[1]) and isNumber(box[3]) and isSendCapability(box[4]) and isText(box[5]))
  then
  <blockquote>
    <p>transmit(box[4],box[5]);
    <p>team(box);</p>
  </blockquote>
  <p>endif;</p>
</blockquote>

<p>endprocedure;

<p>Se você não zerar a escala no 
            balão de pensamento do novo robô, então 
            nós não funcionaremos no caso raro onde box [1] =       
                   
                                             box[3]. A probabilidade de que isto ocorra é de 1 fora da duração média  do ciclo cuja ordem varia entre 10 e 100 dependendo da velocidade do computador envolvido. 

<p><b><b><b>Desafio</b></b> n°55, n°56, n°57, n°58, n°59, e n°60</b>. Intencionalmente deixados em branco. 

<p class=center><br><b><i>Nível 5 - Construindo um Relógio</i></b>

<p><b><b><b>Desafio</b></b> 
            n°61 - Márcio quer um número que se mantém crescente.</b> A solução deste desafio 
            é a mesma do desafio n°50. Aqui, entretanto, o número que se altera tem uma propriedade especial, de tal forma que as mudanças nele se exibem também em outro número. Isto é o que os cientistas da computação chamam de <i>estado comum</i>. Sabe-se que o estado comum causa problemas em programas concorrentes. No ToonTalk, entretanto, os controles remotos funcionam apenas no interior de uma casa isolada, sendo pois esses problemas evitados.

<p><b><b><b>Desafio</b></b> 
            n°62 - Márcio quer que o número aumente em 1.000 a cada segundo.</b> A solução deste desafio 
            exige que se coloque o robô e a caixa atrás do 
            número. Muitos sistemas de desenvolvimento de softwares 
            proporcionam objetos na interface com o usuário que podem ter programas associados com eles. no ToonTalk, você pode colocar robôs atrás das ilustrações para dar a elas qualquer comportamento que você programe. A razão pela qual a solução deste desafio mantém corretamente o tempo, enquanto a solução do desafio anterior não o fazia, é que no desafio prévio o robô ia devagar, de forma que você podia observá-lo.

<p><b><b><b>Desafio</b></b> 
            n°63 - Márcio quer um número que aumente em 1 a cada segundo.</b> A solução para este 
            desafio se baseia nas técnicas de programação utilizadas no nível n°4. Uma das <i>constantes</i> deste robô é 
            que o número do terceiro buraco deve ser 1 menos mil vezes o número do quarto buraco. Outra constante é que o quarto número será 1/1000 do valor do primeiro número. A forma de texto desse robô é:

<p>while (sizeof(box) = 6 and box[0] &gt; box[2] and
isNumber(box[0]) and isNumber(box[2]) and isNumber(box[3]) and isNumber(box[4])&nbsp; and
isNumber(box[5])) do

<blockquote>
  <p>box[2] := box[2] + copy(box[5]);
  <p>box[3] := box[3] + copy(box[4]);
  <p>update_display(box[3]); <em>// update the display
  to show the new value of box[3]</em></p>
</blockquote>

<p>endwhile;

<p><b><b><b>Desafio</b></b> 
            n°64 - Márcio quer um número que aumente em 1 a cada minuto.</b> Este desafio reutiliza o robô do 
            desafio anterior. Os números não se alteraram de tal forma que o robô assegura que o quarto número é 1/60 do primeiro número.

<p><b><b><b>Desafio</b></b> n°65 - Márcio precisa de uma caixa com contadores de horas, minutos e segundos.</b> Construir o contador de horas é o mesmo que construir o contador de minutos no desafio anterior.

<p><b><b><b>Desafio</b></b> 
            n°66 - Márcio quer que o contador de segundos volte para 0 quando alcançar 60.</b> Depois que o robô calcular o 
            primeiro número haverá o resto depois de dividir o que havia por 60. A computação do resto da divisão é implementada pela subtração repetida. É digno de nota que este processo está rodando em paralelo com o processo construído anteriormente, que faz com que o número seja 1/1000 do contador de milissegundos. O robô é equivalente a:

<p>while (sizeOf(box) = 4 and box[0] &gt; box[2] and
isNumber(box[0]) and isNumber(box[2]) and isNumber(box[3]) do

<blockquote>
  <p>box[0] := box[0] + copy(box[3]);&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;&lt; /p&gt;< /p>   
</blockquote>

<p>endwhile;

<p><b><b><b>Desafio</b></b> n°67 - Márcio quer que o contador de minutos volte a zero quando atingir 60.</b> A solução para este problema 
            requer que se perceba que o mesmo robô do desafio anterior é necessário aqui e que você pode utilizar a Varinha Mágica para copiar o robô exigido.

<p><b><b><b>Desafio</b></b> n°68 - Márcio quer que o contador de horas volte a zero quando atingir 24.</b> A solução para este 
            desafio é a mesma do anterior, e adicionalmente você deve alterar os números de forma que o robô se comporte corretamente. Este problema testa sua compreensão dos dois desafios anteriores.

<p><b><b><b>Desafio</b></b> 
            n°69 - Márcio quer que o relógio digital mostre a hora certa.</b> Para resolver este desafio, você simplesmente <i>inicializa</i> os valores dos contadores para a hora atual.

<p><b><b><b>Desafio</b></b> 
            n°70 - Márcio quer um relógio digital de bela aparência.</b> Muitos softwares modernos não apenas 
            precisam computar corretamente, mas também devem exibir informações para os usuários de uma forma atraente e efetiva. Aqui, você precisa fazer que o relógio pareça mais atraente.

<p><b><b><b>Desafio</b></b> n°71 - Márcio quer uma caixa mostrando a hora de seu nascimento.</b> Isto é necessário para o próximo desafio.

<p><b><b><b>Desafio</b></b> 
            n°72 - Márcio deseja saber quantos segundos até que você tenha um número redondo de milhões de segundos de idade.</b> Aqui, você deve baixar o número 
            mostrando sua idade em segundos até zero para congelar o número. Se você tentar subtrair com o contador, então o número continuará a crescer, mesmo quando for negativo. Negligenciar esse procedimento afetará a resposta em apenas poucos segundos.

<p><b><b><b>Desafio</b></b> 
            n°73 - Márcio quer saber quantos minutos até que você tenha um número redondo de milhões de segundos de idade.</b> Este desafio ilustra como o ToonTalk, como a maioria das linguagens de programação, pode realizar a divisão <i>de forma primitiva</i>. Uma vez que o computador 
            principal estava quebrado antes você não podia multiplicar e dividir números e tinha de programar essas operações utilizando adição e subtração.

<p><b><b><b>Desafio</b></b> 
            n°74 - Márcio quer saber quantos dias até que você tenha um número redondo de milhões de segundos de idade.</b> Aqui, você precisa classificar a operação de divisão, em vez de utilizar uma pré-definida.

<p>Se você chegou ao final do jogo de 
            desafio, você deve ter aprendido o suficiente para construir uma ampla variedade de programas em "Free Play". Você pode aprender mais observando alguns dos filmes exemplonstrativos ("Vide exemplos"). Por favor, <A
 href="contribp.html" >compartilhe o que você construiu </A> com os outros.

<p>
<hr size=1><div align=center>
<A class=menu href="toontalk.html" onmouseover="window.status=' Início'; return true">início</A><span class=bola> •</span>
<A class=menu href="search.html" onmouseover="window.status=' Busca'; return true">busca</A><span class=bola> •</span>
<A class=menu href="buy.html" onmouseover="window.status=' Compra'; return true">compra</A><span class=bola> •</span>
<A class=menu href="doc.html" onmouseover="window.status=' Manual'; return true">manual</A><span class=bola> •</span>
<A class=menu href="whatsnew.html" onmouseover="window.status=' Novidades'; return true">novidades</A><span class=bola> •</span>
<A class=menu href="faq.html" onmouseover="window.status=' Dúvidas'; return true">dúvidas</A><span class=bola> •</span>
<A class=menu href="support.html" onmouseover="window.status=' Suporte'; return true">suporte</A><span class=bola> •</span>
<A class=menu href="free.html" onmouseover="window.status=' Download'; return true">download</A><span class=bola> •</span>
<A class=menu href="press.html" onmouseover="window.status=' Imprensa'; return true">imprensa</A><span class=bola> •</span>
<A class=menu href="address.html" onmouseover="window.status=' Contato'; return true">contato</A></div></td>

</tr></table>
</div>
</body></html>

<!--  FuturArte Editora Ltda.                                     Divertire  -->