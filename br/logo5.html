<html>
<head>
<title>ToonTalk - O Logo é uma tecnologia obsoleta? - Parte 5</title>
<link rel="stylesheet" type="text/css" href="ToonTalk.css">
</head>

<body link="#0000ff" vlink="#800080" bgcolor="#ffffff">

<div align="center">
<a name="topo"></a>
<table width=468 cellspacing=0 cellpadding=0 border=0><tr><td>
<p>
<table  cellspacing=0 cellpadding=0 border=0><tr><td>
<div align=center>
<A class=menu href="toontalk.html" onmouseover="window.status=' Início'; return true">in&iacute;cio</a><span class=bola> &#0149;</span>
<A class=menu href="search.html" onmouseover="window.status=' Busca'; return true">busca</a><span class=bola> &#0149;</span>
<A class=menu href="buy.html" onmouseover="window.status=' Compra'; return true">compra</a><span class=bola> &#0149;</span>
<A class=menu href="doc.html" onmouseover="window.status=' Manual'; return true">manual</a><span class=bola> &#0149;</span>
<A class=menu href="whatsnew.html" onmouseover="window.status=' Novidades'; return true">novidades</a><span class=bola> &#0149;</span>
<A class=menu href="faq.html" onmouseover="window.status=' Dúvidas'; return true">d&uacute;vidas</a><span class=bola> &#0149;</span>
<A class=menu href="support.html" onmouseover="window.status=' Suporte'; return true">suporte</a><span class=bola> &#0149;</span>
<A class=menu href="free.html" onmouseover="window.status=' Download'; return true">download</a><span class=bola> &#0149;</span>
<A class=menu href="press.html" onmouseover="window.status=' Imprensa'; return true">imprensa</a><span class=bola> &#0149;</span>
<A class=menu href="address.html" onmouseover="window.status=' Contato'; return true">contato</a>
<hr size=1></div>
    </td></tr>
</table>

<table width=100% cellpadding=5 cellspacing=0>
<tr bgcolor="#fedea0">
	<th><A class=menu href="logo.html">PARTE 1</a></th>
	<th><A class=menu href="logo2.html">PARTE 2</a></th>
	<th><A class=menu href="logo3.html">PARTE 3</a></th>
	<th><A class=menu href="logo4.html">PARTE 4</a></th>
	<th bgcolor="#cc9966"><b>PARTE 5</b></SPAN></th>	
</tr>
</table>

<h1><hr size=1>
            O Logo &eacute; uma tecnologia obsoleta?<hr size=1></h1>

<p class=olho>
Esta &eacute; uma discuss&atilde;o que foi mantida na <A
 href="news:comp.lang.logo" >comp.lang.logo</a> (e na correspondente 
lista de discuss&atilde;o por e-mail de 16 de novembro a 2 de 
dezembro, em 1998. A discuss&atilde;o foi intitulada <a
 href="http://el.www.media.mit.edu/logo-foundation/" 
            target=new_window>&quot;O Logo &eacute; uma tecnologia obsoleta?&quot;</a>    


<p class=autor>
De Ken Kahn:

<p>
&quot;Minhas prioridades: 1. Dar aos estudantes oportunidades ricas e
variadas para expressar seus pensamentos verbal,
visual, auditiva e cinestesicamente.&quot;

<p>
Eu creio que esta &eacute; uma id&eacute;ia 
            muito excitante a ser perseguida. Nesta discuss&atilde;o eu tenho 
            enfatizado a natureza animada/visual do
ToonTalk. Estas outras modalidades sensoriais s&atilde;o importantes e
eu tenho seguido nessa dire&ccedil;&atilde;o. O ToonTalk faz um uso pesado de
efeitos sonoros. Ainda mais interessante, ele usa ao mesmo tempo
voz gravada e um dispositivo texto- narra&ccedil;&atilde;o. Se voc&ecirc; tiver um
joystick com tecnologia &quot;force-feedback&quot; ( custam cerca de 100
d&oacute;lares, por estes dias), ent&atilde;o quando voc&ecirc; utilizar o ToonTalk voc&ecirc;
sentir&aacute; as vibra&ccedil;&otilde;es do motor do helic&oacute;ptero, ou da parede quando
entrar no recinto, ou o peso de alguma coisa em sua m&atilde;o. Nos
pr&oacute;ximos 9 meses, eu planejo integrar entrada de sons (fala) no Toon
Talk.

<p>Talvez n&atilde;o seja necess&aacute;rio 
            diz&ecirc;-lo para esta audi&ecirc;ncia, mas estas modalidades 
            deveriam estar dispon&iacute;veis para que as crian&ccedil;as as
utilizassem em suas pr&oacute;prias cria&ccedil;&otilde;es. Por exemplo, o ToonTalk n&atilde;o
utiliza apenas o force-feedback mas d&aacute; &agrave;s crian&ccedil;as a op&ccedil;&atilde;o de
incluir efeitos de for&ccedil;a em seus pr&oacute;prios programas. Idem para
efeitos sonoros e texto- narra&ccedil;&atilde;o. E entrada de sons(fala) quando
estiver pronta.

<p>
Eu n&atilde;o reivindico ter as respostas para como usar da melhor forma e
integrar essas variadas modalidades. &Eacute; um espa&ccedil;o para a pesquisa
b&aacute;sica, assim como uma variedade de esfor&ccedil;os de planejamento,
para explorar estas quest&otilde;es.

<p>
Sauda&ccedil;&otilde;es,<br>
- Ken Kahn

<p><hr size=1>

<p class=autor>De Ken Kahn:

<p class=reply>
Wen Su escreveu: <br>&quot;Expressar seus pensamentos verbalmente, utilizando computadores,
n&atilde;o &eacute; ainda muito diferente de utilizar l&aacute;pis e pap&eacute;is, como nossa
gera&ccedil;&atilde;o anterior fazia.&quot; 

<p class=reply>
Bastante verdadeiro. O 
            l&aacute;pis &eacute; uma &quot;impressora de qualidade de
letra&quot;. E a express&atilde;o visual em um computador n&atilde;o &eacute; profundamente
diferente de pintar ou desenhar. Eu n&atilde;o desejaria abandonar o l&aacute;pis
e o pincel pelo computador. Os estudantes se beneficiariam pela
exposi&ccedil;&atilde;o a todas estas ferramentas, eu suponho.

<p class=reply>&quot;Eu hesito em ser `do 
            contra&acute; aqui. Mas embora seja muito bom
fornecer aos estudantes uma ferramenta de constru&ccedil;&atilde;o multim&iacute;dia de
forma que eles possam expressar seus pensamentos atrav&eacute;s destas
novas ferramentas multim&iacute;dia, muitas ferramentas atuais n&atilde;o s&atilde;o
ainda simples o bastante para serem utilizadas por jovens (ou
mesmo por adultos).&quot; 

<p class=reply>Novamente verdadeiro... como 
            tamb&eacute;m para o l&aacute;pis e o pincel.
Apenas pergunte a um estudante se o que ele est&aacute; escrevendo &eacute;
f&aacute;cil. Tente apenas pintar uma imagem e obt&ecirc;-la do jeito que deseja. 

<p class=reply>
Tom Woods

<p><hr size=1>

<p><b>Ken Kahn escreveu:</b>

<p>&quot;Nesta discuss&atilde;o eu tenho enfatizado a natureza animada/visual do
ToonTalk. Estas outras modalidades sensoriais s&atilde;o importantes...&quot;<br>
<br>
 AGORA voc&ecirc; 
            est&aacute; dizendo que quando tiver a narra&ccedil;&atilde;o funcionando,
voc&ecirc; ter&aacute; o equivalente de texto tamb&eacute;m? Isto seria extremamente
ben&eacute;fico para novos e emergentes leitores que freq&uuml;entemente
come&ccedil;am lendo palavras que eles mesmos escreveram ou falaram.
Voc&ecirc; pode estar fazendo algo importante.<br>
<br><br>
Tom Woods


<p><br>
<hr size=1>

<p><b>Ken Kahn escreveu:</b>

<p>
Eu concordo que a maioria das pessoas aprecia o que elas j&aacute;
conhecem. Isto pode significar que os professores n&atilde;o dar&atilde;o ao
ToonTalk a chance que ele merece.

<p>E tamb&eacute;m em outra mensagem em r&eacute;plica a Tom Woods:

<p>&quot;Talvez eu deva reformular a 
            quest&atilde;o da obsolesc&ecirc;ncia do Logo
como 'o Logo &eacute; ainda a melhor primeira linguagem a ser aprendida
pelas crian&ccedil;as?'. Eu n&atilde;o creio. Eu acho que as linguagens
visuais/animadas s&atilde;o mais atraentes para as crian&ccedil;as e mais f&aacute;ceis
de aprender.&quot;

<p>Eu aprecio a forma pela qual voc&ecirc; reformulou seu desafio ao Logo, o
que o torna mais agrad&aacute;vel para que eu observe o ToonTalk, quando
tiver tempo para escrever relat&oacute;rios.

<p>Com rela&ccedil;&atilde;o aos professores dando ao TT a chance que ele
merece: isto me faz pensar em alguma coisa em um livro chamado
&quot;Learning in Science&quot;, de Osborne &amp; Freyberg (&eacute; um livro acerca de
Ci&ecirc;ncia para crian&ccedil;as.), o qual eu acabei de rever para refrescar
minha mem&oacute;ria, eu cito:

<p>&quot;As id&eacute;ias perdem `status&acute; 
            quando se tornam menos intelig&iacute;veis,
plaus&iacute;veis e frut&iacute;feras. Inversamente, novas id&eacute;ias aumentam seu
prest&iacute;gio quando se tornam mais intelig&iacute;veis, mais plaus&iacute;veis e mais
frut&iacute;feras&quot;. (48) [Eles escrevem mais sobre o que querem dizer com
estes termos.]

<p>Embora eu tivesse estado interessado muito 
            tempo no MicroWorlds
e o avalie bem nestes tr&ecirc;s crit&eacute;rios, eu penso que deveria dar uma boa olhada em sua alternativa.
Seria ing&ecirc;nuo pensar que a pr&oacute;xima evolu&ccedil;&atilde;o do Logo/MicroWorlds ser&aacute; &quot;sempre&quot; a melhor primeira linguagem para crian&ccedil;as. A partir de outras perspectivas eu vejo outros problemas, entretanto:

<p>Minha perspectiva: a tentativa que voc&ecirc; est&aacute; efetuando em
compara&ccedil;&atilde;o com o Superlogo n&atilde;o o MicroWorlds (eu n&atilde;o sei muito
sobre o SuperLogo).

<p>Sua perspectiva (minha tamb&eacute;m): o 
            mercado real para linguagens de
programa&ccedil;&atilde;o para crian&ccedil;as parece estar encolhendo, quando
simula&ccedil;&otilde;es mais sofisticadas pr&eacute;-realizadas, como o &quot;sim-life&quot;
etc... v&ecirc;m &agrave; tona.

<p>
Bill Kerr


<p><hr size=1>

<p class=autor>Brian Harvey escreveu:

<p>&quot;Eu n&atilde;o compreendo isto. Se os 
            processos estavam embutindo a recurs&atilde;o, e portanto voc&ecirc; 
            realmente precisava manter a totalidade
dos estados de todas as chamadas de procedimento ao redor, ent&atilde;o
eu n&atilde;o entendo por que voc&ecirc; o est&aacute; evitando. Se sua queixa &eacute; que a
pilha de Java cresce atr&aacute;s das chamadas, ent&atilde;o o problema n&atilde;o s&atilde;o
as sub-rotinas, mas as implementa&ccedil;&otilde;es de linguagens inferiores.
Utilize, ao inv&eacute;s, a Logo Berkeley! Ela corrigir&aacute; a elimina&ccedil;&atilde;o de
chamadas por tr&aacute;s.&quot;

<p>Eu concordo que as linguagens de 
            procedimentos devem fazer a otimiza&ccedil;&atilde;o da 
            recurs&atilde;o por tr&aacute;s. Mas eu estava tentando destacar 
            outro ponto. O ToonTalk poderia ser implementado como uma
cole&ccedil;&atilde;o de registros de processos n&atilde;o-ordenados. Um registro de
processo &eacute; como uma estrutura de pilhas &ndash; ele cont&eacute;m um indicador
para o c&oacute;digo (rob&ocirc;s, no ToonTalk) e um vetor de argumento (uma
caixa, no ToonTalk). Para ser justo com as linguagens
convencionais, apesar de o ToonTalk ter processos muito
econ&ocirc;micos, as chamadas de procedimentos ordin&aacute;rias s&atilde;o mais
custosas desde que elas utilizam o &quot;heap&quot; (&aacute;rea da mem&oacute;ria) em vez da pilha. Mas o fato de que as pilhas n&atilde;o s&atilde;o utilizadas &eacute; que
define por que a gera&ccedil;&atilde;o, suspens&atilde;o e t&eacute;rmino dos processos s&atilde;o
t&atilde;o econ&ocirc;micos no ToonTalk.

<p>&quot;Mas (e este &eacute; o ponto principal 
            que quero destacar aqui) existe outra forma de armar a 
            concorr&ecirc;ncia sem incorrer em erros de 
            sincroniza&ccedil;&atilde;o: programa&ccedil;&atilde;o funcional! As 
            condi&ccedil;&otilde;es de sa&iacute;da s&atilde;o poss&iacute;veis 
            apenas se os diversos `threads&acute; est&atilde;o assinalando novos
valores para as vari&aacute;veis. Mas n&atilde;o h&aacute; necessidade de faz&ecirc;-lo (em
termos do Logo, voc&ecirc; nunca precisa utilizar MAKE).
Quando voc&ecirc; agrega programa&ccedil;&atilde;o funcional com programa&ccedil;&atilde;o seq&uuml;encial,  eu creio que voc&ecirc; n&atilde;o est&aacute; fazendo justi&ccedil;a ao poder da chamada de
procedimento como um mecanismo de controle. Algumas
computa&ccedil;&otilde;es realmente se aplicam, a si mesmas, ao modelo
imperativo de programa&ccedil;&atilde;o que voc&ecirc; descreve. Mas o que ocorre
com o exemplo cl&aacute;ssico do Logo da gera&ccedil;&atilde;o de uma senten&ccedil;a
inglesa? Eu creio que isto &eacute; melhor descrito como uma composi&ccedil;&atilde;o
de fun&ccedil;&otilde;es. E mesmo se os argumentos para as fun&ccedil;&otilde;es s&atilde;o
corretamente computados, n&atilde;o h&aacute; problema de sincroniza&ccedil;&atilde;o.&quot;

<p>
Eu concordo que em programas sem efeitos 
            colaterais como na programa&ccedil;&atilde;o funcional todas as 
            minhas obje&ccedil;&otilde;es e preocupa&ccedil;&otilde;es
acerca da sincroniza&ccedil;&atilde;o desaparecem. E eu concordo que alguns
programas interessantes podem ser escritos em um estilo funcional
puro, por exemplo, seu gerador de senten&ccedil;a. Mas (e este &eacute; meu
ponto principal aqui) existem muitos programas que n&atilde;o podem ser
escritos como fun&ccedil;&otilde;es puras. O exemplo da conta banc&aacute;ria que eu
dei anteriormente &eacute; um deles. Ou um marcador de pontos em um
jogo. Ou muitas simula&ccedil;&otilde;es, anima&ccedil;&otilde;es, jogos etc. Mesmo
programas que fazem I/O s&atilde;o dif&iacute;ceis de se encaixar em estruturas
puramente funcionais.

<p>&quot;Agora, por um lado, voc&ecirc; 
            proporciona chamada de fun&ccedil;&otilde;es, com os Pombos 
            etc. Mas eu penso que, devido a voc&ecirc; depreciar a id&eacute;ia,
sua met&aacute;fora torna a chamada de fun&ccedil;&atilde;o muito mais complicada do
que deveria ser. Eu ainda n&atilde;o vejo por que toda chamada de fun&ccedil;&atilde;o
DEVE ser um processo separado &ndash; talvez porque eu n&atilde;o entenda o
que voc&ecirc; est&aacute; falando acerca de espa&ccedil;o na pilha. Voc&ecirc; est&aacute; dizendo
que os processos separados asseguram a n&atilde;o-muta&ccedil;&atilde;o de vari&aacute;veis
compartilhadas? Voc&ecirc; n&atilde;o poderia atingir o mesmo objetivo n&atilde;o
permitindo que os rob&ocirc;s (procedimentos, eu entendi) mudassem as
coisas fora de si mesmos?&quot;

<p>
Eu deveria antes dizer que eu proporciono 
            uma t&eacute;cnica de programa&ccedil;&atilde;o ou padr&atilde;o de 
            utiliza&ccedil;&atilde;o do ToonTalk que corresponde exatamente 
            &agrave; chamada de fun&ccedil;&atilde;o. E eu admito que &eacute; um pouco mais
complicado quando tudo o que voc&ecirc; deseja fazer &eacute; uma chamada de
fun&ccedil;&atilde;o. Mas eu afirmo que voc&ecirc; deseja algo mais geral que a
chamada de fun&ccedil;&atilde;o. Suponha que voc&ecirc; deseja devolver dois itens.
No ToonTalk voc&ecirc; apenas coloca dois Pombos em uma caixa e
enquanto os valores s&atilde;o computados eles s&atilde;o dados aos Pombos
e seus ninhos correspondentes s&atilde;o preenchidos. Suponha que voc&ecirc;
n&atilde;o deseja um valor simples, mas um fluxo de respostas. Talvez
mesmo um fluxo infinito (por exemplo o Cone de Erat&oacute;stenes
gerador de n&uacute;meros primos). Suponha que voc&ecirc; deseja criar uma
rede de agentes cooperativos. E por que algu&eacute;m deveria for&ccedil;ar a
passagem de mensagens entre objetos para ajustar-se &agrave; estrutura
da chamada de fun&ccedil;&atilde;o?

<p>N&oacute;s poexemplos estar perdendo todos, menos os programadores e
cientistas da computa&ccedil;&atilde;o nesta lista, mas eu creio que s&atilde;o bons
artigos. Eu estou aprendendo como ser mais claro acerca do que
estou fazendo.

<p>
Sauda&ccedil;&otilde;es,<br>
- Ken Kahn (<a HREF="http://www.ToonTalk.com/">www.ToonTalk.com</a>)


<p><hr size=1>

<p class=autor>De Brian Harvey:

<p>Eu temo que ainda n&atilde;o compreendi; por que uma estrutura na pilha &eacute;
mais custosa que uma no &quot;heap&quot;? &Eacute; esta alguma caracter&iacute;stica
espec&iacute;fica do PC que eu n&atilde;o conhe&ccedil;o? 

<p>&quot;Eu deveria antes dizer que eu 
            proporciono uma t&eacute;cnica de programa&ccedil;&atilde;o ou 
            padr&atilde;o de utiliza&ccedil;&atilde;o do ToonTalk que corresponde
exatamente &agrave; chamada de fun&ccedil;&atilde;o. E eu admito que &eacute; um pouco mais
complicado quando tudo o que voc&ecirc; deseja fazer &eacute; uma chamada de
fun&ccedil;&atilde;o. Mas eu afirmo que voc&ecirc; deseja algo mais geral que a
chamada de fun&ccedil;&atilde;o. Suponha que voc&ecirc; deseja devolver dois itens.&quot;

<p>Interessante &ndash; n&oacute;s estamos tendo exatamente o mesmo argumento
agora na comp.lang.scheme; os tipos implementadores t&ecirc;m
colocado em valores de retorno m&uacute;ltiplos por raz&otilde;es de efici&ecirc;ncia, e os f&atilde;s lambda o odiaram. 

<p>Mas eu n&atilde;o desejo que voc&ecirc; 
            fa&ccedil;a tudo funcionalmente. O que eu quero &eacute; uma 
            linguagem que n&atilde;o imponha um paradigma para mim,
mas permita-me escolher o que &eacute; melhor para o programa a m&atilde;o.
Portanto, n&atilde;o &eacute; que eu deseje que voc&ecirc; deixe nada de fora; eu
desejo que voc&ecirc; fa&ccedil;a a composi&ccedil;&atilde;o de fun&ccedil;&atilde;o mais f&aacute;cil, tamb&eacute;m! 

<p><hr size=1>

<p class=autor>Brian Harvey escreveu na mensagem...

<p>Eu acredito que este pode ser o centro da 
            nossa discord&acirc;ncia. N&atilde;o est&aacute; muito claro aquela afirma&ccedil;&atilde;o em que voc&ecirc; quer dizer &quot;simples para o implementador&quot; ou &quot;simples para o usu&aacute;rio&quot;. <br><br>

Se o for para o primeiro, n&oacute;s, em princ&iacute;pio, 
            discordamos. Se for para o segundo, n&oacute;s discordamos quanto &agrave; estrat&eacute;gia de interface com o usu&aacute;rio. Eu n&atilde;o estou convencido de que os meios simplificados &quot;d&atilde;o ao usu&aacute;rio um martelo e o ensinam que tudo s&atilde;o pregos!&quot; <br><br>

Eu quero dizer o usu&aacute;rio. Embora eu gostasse de 
            usu&aacute;rios avan&ccedil;ados para ter uma id&eacute;ia boa de como as coisas s&atilde;o implementadas. Os cursos de Scheme e Lisp n&atilde;o ensinam aos estudantes como escrever interpretadores de meta? Isso &eacute; muito mais dif&iacute;cil de fazer se a linguagem n&atilde;o for simples.<br><br>

Quando eu cheguei &agrave; Xerox PARC (1984), fiquei bastante envolvido em um projeto de linguagem de m&uacute;ltiplos paradigmas (chamado Loops, depois InterLoops, depois CommonLoops, e eu sa&iacute; fora quando ele passou a ser chamado de CLOS). Eu me lembro de estar revisando um papel escrito para a Bell Labs que discutia persuasivamente que havia custos cognitivos e colaboradores muito grandes para usar tais linguagens ricas.<br><br>

Convenceram-me de que &eacute; dif&iacute;cil para a maioria das pessoas trocar entre paradigmas de programa&ccedil;&atilde;o diferentes mantendo as particularidades que essas linguagens permitem. E o autor do papel relatou os problemas &agrave;s equipes da Bell Labs que teve devido a diferentes membros estarem usando modos muito diferentes de programar.<br><br>

Os membros da equipe acharam dif&iacute;cil de entender e mudar para outro c&oacute;digo. Tamb&eacute;m pode haver interfer&ecirc;ncia entre as partes. Um componente do tipo Prolog, de programa&ccedil;&atilde;o l&oacute;gica, tem dificuldades ao integrar bem uma linguagem imperativa substituta. <br><br>

Um componente funcional puro permite 
            todos os tipos de transforma&ccedil;&otilde;es de programa e 
            execu&ccedil;&otilde;es paralelas que quebram quando integrados com linguagens com efeitos colaterais. Voc&ecirc; come&ccedil;ou esta discuss&atilde;o inteira dizendo que a inform&aacute;tica mudou desde o surgimento do Logo, e n&oacute;s dever&iacute;amos apoiar novos paradigmas. Portanto, eu acredito que vale a pena observar que as linguagens populares que s&atilde;o compat&iacute;veis com paralelismo e OOP n&atilde;o exclu&iacute;ram outros mecanismos expressivos; pois isto &eacute; exclusivo ao TT.<br><br>

Sim, a corrente principal acrescentou 
            paralelismo &agrave;s estruturas existentes. E os programadores profissionais t&ecirc;m uma dura tarefa de compreender e depurar programas Java com segmentos (e o Java &eacute; um dos melhores exemplos para isto). Os cientistas da computa&ccedil;&atilde;o continuam explorando a linguagem de programa&ccedil;&atilde;o atora, funcional, baseada em l&oacute;gica e constraints que, assim como o ToonTalk, despreza algumas id&eacute;ias antigas para ir em busca do progresso. Por outro lado, a ind&uacute;stria de computadores, ou corrente principal, simplesmente tenta enxertar coisas novas no velho. Este grupo de not&iacute;cias &eacute; sobre o Logo &ndash; sobre linguagens de programa&ccedil;&atilde;o poderosas para crian&ccedil;as.<br><br>

Ao 
            contr&aacute;rio da corrente principal, as constraints de sistemas 
            legados e retrocessos de compatibilidade s&atilde;o m&iacute;nimos. E n&oacute;s poexemplos dar &agrave;s crian&ccedil;as a habilidade de criar programas paralelos sem for&ccedil;&aacute;-las a dominar a complexidade de travas e regi&otilde;es at&ocirc;micas. E sem esperar que elas depurem condi&ccedil;&otilde;es de competi&ccedil;&atilde;o e paralisa&ccedil;&otilde;es completas.<br><br> 

<p>
Sauda&ccedil;&otilde;es,<br>
Ken Kahn (<a HREF="http://www.ToonTalk.com/">www.ToonTalk.com</a>)<br>

<p><hr size=1>

<p class=autor>Ken Kahn&quot; &lt;<A
 href="mailto:KenKahn@ToonTalk.com" >KenKahn@ToonTalk.com</a>&gt; escreveu:

<p>
Eu me lembro de estar revisando um papel escrito para a Bell Labs que discutia persuasivamente que havia custos cognitivos e colaboradores muito grandes para usar tais linguagens ricas.
Convenceram-me de que &eacute; dif&iacute;cil para a maioria das pessoas trocar entre paradigmas de programa&ccedil;&atilde;o diferentes mantendo as particularidades que essas linguagens permitem. Eu acho que eu gostaria de saber se todos os paradigmas s&atilde;o igualmente dif&iacute;ceis neste sentido. <br><br>

Minha 
            experi&ecirc;ncia de ensino me fez (relutantemente!) concluir que a 
            programa&ccedil;&atilde;o seq&uuml;encial &eacute; muito natural 
            para a maioria das pessoas, e que programa&ccedil;&atilde;o funcional exige maior esfor&ccedil;o mental (embora a compensa&ccedil;&atilde;o por esse esfor&ccedil;o seja evidente). Onde est&aacute; a programa&ccedil;&atilde;o simult&acirc;nea naquele padr&atilde;o? O que significa manter o custo marginal da composi&ccedil;&atilde;o de fun&ccedil;&atilde;o em uma linguagem, naquele padr&atilde;o, <i>versus</i> o custo 
            marginal da simultaneidade inclusa? Tamb&eacute;m pode haver interfer&ecirc;ncia entre as partes.<br><br>

Um componente do tipo Prolog, de 
            programa&ccedil;&atilde;o l&oacute;gica, tem dificuldades ao integrar bem uma linguagem imperativa substituta. Um componente funcional puro permite todos os tipos de transforma&ccedil;&otilde;es de programa e execu&ccedil;&otilde;es paralelas que quebram quando integrados com linguagens com efeitos colaterais. Tamb&eacute;m pode haver interfer&ecirc;ncia entre as partes. Um componente do tipo Prolog, de programa&ccedil;&atilde;o l&oacute;gica, tem dificuldades ao integrar bem uma linguagem imperativa substituta.<br><br>

Um componente funcional puro permite todos os tipos de 
            transforma&ccedil;&otilde;es de programa e execu&ccedil;&otilde;es paralelas que quebram quando integrados com linguagens com efeitos colaterais. Eu concordava com voc&ecirc; no exemplo de programa&ccedil;&atilde;o l&oacute;gica, mas o funcional me parece ser um pouco fals&aacute;rio; l&aacute; voc&ecirc; est&aacute; falando sobre complexidade para o implementador, e n&atilde;o sobre carga cognitiva para o usu&aacute;rio. Sim, a corrente principal acrescentou paralelismo &agrave;s estruturas existentes. <br><br>

E os programadores 
            profissionais t&ecirc;m uma dura tarefa de compreender e depurar programas Java com segmentos (e o Java &eacute; um dos melhores exemplos para isto). Os cientistas da computa&ccedil;&atilde;o continuam explorando a linguagem de programa&ccedil;&atilde;o atora, funcional, baseada em l&oacute;gica e constraints que, assim como o ToonTalk, despreza algumas id&eacute;ias antigas para ir em busca do progresso. Por outro lado, a ind&uacute;stria de computadores, ou corrente principal, simplesmente tenta enxertar coisas novas no velho. Sim, a corrente principal acrescentou paralelismo &agrave;s estruturas existentes.<br><br>

Eu estou convencido de que &eacute; dif&iacute;cil depurar 
            programas que combinam simultaneidade com muta&ccedil;&atilde;o de 
            vari&aacute;veis compartilhadas. Mas n&atilde;o estou convencido de 
            que voc&ecirc; n&atilde;o pode ter tudo da * simultaneidade * composi&ccedil;&atilde;o de fun&ccedil;&otilde;es sem muta&ccedil;&atilde;o * muta&ccedil;&atilde;o (n&atilde;o-compartilhada) de vari&aacute;veis locais tudo na mesma linguagem, sem problemas. PS. Na Scheme n&oacute;s poexemplos fazer funcional, seq&uuml;encial, simult&acirc;neo e OOP, embora a Scheme seja, pelo menos sob um sentido, uma linguagem muito simples. Ela n&atilde;o possui milh&otilde;es de primitivas, como a CLOS, ou muita sintaxe, como o Java. N&oacute;s tentamos ensinar aos nossos estudantes a usar v&aacute;rios paradigmas de programa&ccedil;&atilde;o, mas prestar aten&ccedil;&atilde;o a qual eles est&atilde;o usando. <br><br>

Eu suspeito que esses programadores que voc&ecirc; mencionou que misturaram estilos adotaram uma Common Lisp manual sem nenhuma instru&ccedil;&atilde;o expl&iacute;cita sobre paradigmas.<br><br>

<p><hr size=1>

<p class=autor>Brian Harvey escreveu na mensagem &lt;<A
 href="mailto:73v2ml$lk6$1@agate.berkeley.edu" >73v2ml$lk6$1@agate.berkeley.edu</a>&gt;...

<p>Eu acho que eu gostaria de saber se todos os paradigmas s&atilde;o igualmente dif&iacute;ceis neste sentido.<br><br>

Minha 
            experi&ecirc;ncia de ensino me fez (relutantemente!) concluir que a programa&ccedil;&atilde;o seq&uuml;encial &eacute; muito natural para a maioria das pessoas, e que programa&ccedil;&atilde;o funcional exige maior esfor&ccedil;o mental (embora a compensa&ccedil;&atilde;o por esse esfor&ccedil;o seja evidente). <br><br>

Onde est&aacute; a 
            programa&ccedil;&atilde;o simult&acirc;nea naquele padr&atilde;o? O que significa manter o custo marginal da composi&ccedil;&atilde;o de fun&ccedil;&atilde;o em uma linguagem, naquele padr&atilde;o, <i>versus</i> o custo marginal da simultaneidade inclusa? Perguntas muito boas! Algu&eacute;m conhece uma pesquisa que foi feita para dar as respostas a estes tipos de perguntas? Ou nos computadores e na literatura educacional ou na psicologia de programa&ccedil;&atilde;o? <br><br>

(A &uacute;nica coisa que eu posso pensar &eacute; que a tese de mestrado de Mitch Resnick sobre o MultiLogo.) Um componente funcional puro permite todos os tipos de programa transforma&ccedil;&otilde;es e execu&ccedil;&otilde;es paralelas que quebram quando integradas com linguagens com efeitos colaterais. <br><br>

Aquela que &eacute; 
            funcional me parece ser um pouco de fals&aacute;rio; l&aacute; vem 
            voc&ecirc; falando sobre complexidade para o implementador, n&atilde;o em carga cognitiva para o usu&aacute;rio. Que tal nos preocuparmos com a ordem de execu&ccedil;&atilde;o dos argumentos para uma fun&ccedil;&atilde;o? No caso, voc&ecirc; n&atilde;o precisa se aborrecer com isso. Caso haja efeitos colaterais, voc&ecirc; agora tem uma coisa a mais para se lembrar. Eu estou convencido de que &eacute; dif&iacute;cil depurar programas que combinam simultaneidade com muta&ccedil;&atilde;o de vari&aacute;veis compartilhadas. <br><br>

Mas n&atilde;o estou convencido de que 
            voc&ecirc; n&atilde;o pode ter tudo da * simultaneidade * 
            composi&ccedil;&atilde;o de fun&ccedil;&otilde;es sem muta&ccedil;&atilde;o * muta&ccedil;&atilde;o (n&atilde;o-compartilhada) de vari&aacute;veis locais tudo na mesma linguagem, sem problemas. Eu n&atilde;o tenho certeza. N&oacute;s simplesmente teremos de esperar at&eacute; que algu&eacute;m o construa (ou pelo menos o projete detalhadamente). <br><br>

Mas voc&ecirc; dever&aacute; 
            concordar que n&atilde;o h&aacute; nenhum dialeto do Logo que satisfa&ccedil;a esses crit&eacute;rios, certo?<br><br>
<br>
<br>
Sauda&ccedil;&otilde;es,<br>
<br>
- Ken Kahn (<a HREF="http://www.ToonTalk.com/">www.ToonTalk.com</a>)</FONT></p>


<p><hr size=1>

<p class=autor>luvisi@andru.sonoma.edu escreveu:

<p>Existem muitas linguagens que compartilham o mesmo modelo de computa&ccedil;&atilde;o do ToonTalk &ndash; Concurrent Prolog, Parlog, Guarded Horn Clauses, Strand, KL1, OC, Herbrand, Janus, Linear Janus e Oz. Voc&ecirc; poderia dar alguns URLs e recomenda&ccedil;&otilde;es de livros? <br><br>

Como um resolvedor de problemas profissional e sendo um ser humano, eu
sempre estou tentando encontrar novas maneiras de encarar os problemas. Muito bom, mas te&oacute;rico: Concurrent Constraint Programming (Acm Doctoral Dissertation Awards) Vijay A. Saraswat / Hardcover / publicado em 1993. Nosso pre&ccedil;o: US$ 55.00 (pedido especial). Leia mais sobre esse t&iacute;tulo... N&atilde;o li, mas deveria. <br><br>

Parece bom: Objects for Concurrent Constraint Programming (Klwer International Series in Engineering and Computer Science, 426) Martin Henz / Hardcover / publicado em 1997. <br><br>

Um pouco velho, mas uma boa colet&acirc;nea de artigos; 
            Concurrent Prolog : Collected Papers (Logic Programming Series) Ehud Shapiro(Editor) / Hardcover / publicado em 1988 Considere a diferen&ccedil;a entre: cout &lt;&lt; 2 &lt;&lt;  3; == (  cout.operator&lt;&lt;( 2) ).operator&lt;&lt;( 2 );= 23 e:  cout &lt;&lt; (2  &lt;&lt;  3); == (cout.operator&lt;&lt;(2 &lt;&lt;  3 ); = 16 Eu sou o &uacute;nico a achar que isso &eacute; um pouco complicado? Ver isso me deixa contente por erros de sintaxe e confus&otilde;es n&atilde;o serem um problema do ToonTalk.<br><br>


<hr size=1>
<A class=menu href="toontalk.html">in&iacute;cio</a> <span class=bola> &#0149;</span>
<A class=menu href="search.html">busca</a> <span class=bola> &#0149;</span>
<A class=menu href="buy.html">adquira</a> <span class=bola> &#0149;</span>
<A class=menu href="doc.html">manual</a> <span class=bola> &#0149;</span>
<A class=menu href="whatsnew.html">novidades</a> <span class=bola> &#0149;</span>
<A class=menu href="faq.html">d&uacute;vidas</a> <span class=bola> &#0149;</span>
<A class=menu href="support.html">suporte</a> <span class=bola> &#0149;</span>
<A class=menu href="free.html">download</a> <span class=bola> &#0149;</span>
<A class=menu href="press.html">imprensa</a> <span class=bola> &#0149;</span>
<A class=menu href="address.html">contato</a> 
    


</td></tr></table>
</div>
</body></html>

<!--  FuturArte Editora Ltda.                                     Divertire  -->